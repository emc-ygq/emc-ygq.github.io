<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="简历上的面试题技术栈面试题1234567891011121314151617181920212223java虚拟机有一定了解，掌握垃圾回收(垃圾回收算法，垃圾回收器CMS,G1，三色标记)，类加载(流程，双亲委派)，内存结构。熟练运用 Spring(IOC，AOP，三级缓存，Bean的生命周期)，、Mybatis&#x2F;Mybatis Plus、Spring Boot等开源框架。深入理解MySQL底层原">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/01/31/%E7%AE%80%E5%8E%86%E4%B8%8A%E7%9A%84%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="简历上的面试题技术栈面试题1234567891011121314151617181920212223java虚拟机有一定了解，掌握垃圾回收(垃圾回收算法，垃圾回收器CMS,G1，三色标记)，类加载(流程，双亲委派)，内存结构。熟练运用 Spring(IOC，AOP，三级缓存，Bean的生命周期)，、Mybatis&#x2F;Mybatis Plus、Spring Boot等开源框架。深入理解MySQL底层原">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021171354105.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021184932165.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021190340857.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021185435376.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241022173317423.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241022235744956.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024143845394.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024143932862.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024144010001.png">
<meta property="og:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024144916448.png">
<meta property="article:published_time" content="2025-01-31T13:39:38.162Z">
<meta property="article:modified_time" content="2024-10-28T13:29:28.539Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021171354105.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-简历上的面试回答" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/31/%E7%AE%80%E5%8E%86%E4%B8%8A%E7%9A%84%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94/" class="article-date">
  <time class="dt-published" datetime="2025-01-31T13:39:38.162Z" itemprop="datePublished">2025-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简历上的面试题"><a href="#简历上的面试题" class="headerlink" title="简历上的面试题"></a>简历上的面试题</h1><h2 id="技术栈面试题"><a href="#技术栈面试题" class="headerlink" title="技术栈面试题"></a>技术栈面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java虚拟机有一定了解，掌握垃圾回收(垃圾回收算法，垃圾回收器CMS,G1，三色标记)，类加载(流程，双亲委派)，内存结构。</span><br><span class="line"></span><br><span class="line">熟练运用 Spring(IOC，AOP，三级缓存，Bean的生命周期)，、Mybatis/Mybatis Plus、Spring Boot等开源框架。</span><br><span class="line"></span><br><span class="line">深入理解MySQL底层原理，对于MySQL索引(索引失效，索引下推，索引覆盖)、事务机制(ACID，MVCC)有一定的研究，对SQL调优有一定了解，了解mysql的分库分表以及sharding-jdbc的实现。</span><br><span class="line"></span><br><span class="line">熟练掌握Maven工具，在项目中实现自动化构建、版本控制及依赖管理，提升开发效率与团队协作能力。</span><br><span class="line"></span><br><span class="line">熟悉Redis缓存解决方案，数据结构(底层实现，应用场景)，持久化，一致性，缓存雪崩击穿、穿透(解决方案)，限流，以及如何使用Redis实现排行榜。</span><br><span class="line"></span><br><span class="line">熟悉多线程编程，掌握synchronized(锁升级)，线程池(参数，工作流程) ，ThreadLocal(内存泄露)。</span><br><span class="line"></span><br><span class="line">熟悉spring cloud微服务技术及其组件的使用 nacos gatway feign okhttp等。</span><br><span class="line"></span><br><span class="line">了解常见的设计模式，能在项目中使用单例，工厂，策略模式。</span><br><span class="line"></span><br><span class="line">了解RabbitMQ消息队列中间件，理解其在异步通信、系统解耦等方面的应用价值。</span><br><span class="line"></span><br><span class="line">熟悉HTML、CSS、JavaScript等前端基础技术，同时掌握Vue.js框架，能够参与前后端分离项目的前端开发工作，提升用户体验与交互效果。</span><br><span class="line"></span><br><span class="line">了解基础的linux命令。</span><br><span class="line"></span><br><span class="line">了解 Git，Docker，Nginx(反向代理，负载均衡)等编程辅助工具。</span><br></pre></td></tr></table></figure>



<h3 id="1-java虚拟机"><a href="#1-java虚拟机" class="headerlink" title="1. java虚拟机"></a>1. java虚拟机</h3><h4 id="1-1-虚拟机的内存结构"><a href="#1-1-虚拟机的内存结构" class="headerlink" title="1.1 虚拟机的内存结构"></a>1.1 虚拟机的内存结构</h4><p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021171354105.png" alt="image-20241021171354105"></p>
<p><strong>程序计数器（Program Counter Register）：</strong></p>
<p>程序计数器是一块很小的内存空间，它是<strong>线程私有</strong>的，可以认作为<strong>当前线程的行号指示器</strong>。</p>
<blockquote>
<p>一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OOM的区域。</p>
</blockquote>
<p><strong>Java 虚拟机栈（Java Virtual Machine Stacks）：</strong></p>
<p>虚拟机栈也是线程私有的，生命周期与程序计数器相同，就是我们平时说的栈，栈描述的是Java方法执行的内存模型。</p>
<blockquote>
<p>①<strong>每创建一个线程</strong>，虚拟机就会为这个线程<strong>创建一个虚拟机栈</strong>，<br>②虚拟机栈表示Java方法执行的内存模型，<strong>每调用一个方法</strong>，就会<strong>生成一个栈帧</strong>（Stack Frame）用于存储方法的局部变量表、操作栈、方法出口等信息，当这个方法执行完后，就会弹出相应的栈帧。</p>
<p><strong>逃逸分析</strong>：当虚拟机判断改对象只在改方法中使用的时候，不会选择在堆中去开辟空间，而且直接在栈上分配内存</p>
<p>如果改对象的所有属性都可以独立处理，JVM可能会将对象<strong>标量替换</strong>将其分解为基本的成员变量。这会减少垃圾回收器的压力这是在栈上分配，方法执行结束就自动释放。</p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021184932165.png" alt="image-20241021184932165"></p>
</blockquote>
<p><strong>本地方法栈（Native Method Stack）：</strong></p>
<p>与虚拟机栈类似，只是是执行本地方法时使用的，本地方法栈则为 JVM 使用到的 Native 方法服务。</p>
<p><strong>Java 堆（Java Heap）：</strong></p>
<p>Java 虚拟机中内存大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存,<strong>虚拟机中用于存放对象与数组实例的地方</strong>，垃圾回收的主要区域就是这里（还可能有方法区）;</p>
<p>在 Java 中，堆被划分成两个不同的区域：<strong>新生代 ( Young )</strong>、<strong>老年代 ( Old )</strong>。</p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021190340857.png" alt="image-20241021190340857"></p>
<p>新生代又可能分为<strong>Eden</strong>区，<strong>From Survivor</strong>区和<strong>To Survivor</strong>区，主要是为了垃圾回收。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>堆的大小可以通过参数 <strong>–Xms</strong>、**-Xmx **来指定。</p>
<p>Java堆只要求逻辑上是连续的，在物理空间上可以不连续。</p>
<p><strong>方法区（Methed Area）：</strong></p>
<p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
<p>方法区是线程间共享的，当两个线程同时需要加载一个类型时，只有一个类会请求ClassLoader加载，另一个线程会等待。</p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241021185435376.png" alt="image-20241021185435376"></p>
<ul>
<li><code>常量池大体可以分为：静态常量池，运行时常量池。</code></li>
</ul>
<p><strong>静态常量池</strong> : 存在于class文件中，比如经常使用的javap -verbose中，常量池总是在最前面</p>
<p><strong>运行时常量池</strong>：就是在class文件被加载进了内存之后，常量池保存在了方法区中，通常说的常量池 指的是运行时常量池。所以呢，讨论的都是运行时常量池</p>
<h3 id="1-2-垃圾收集算法"><a href="#1-2-垃圾收集算法" class="headerlink" title="1.2 垃圾收集算法"></a>1.2 垃圾收集算法</h3><ul>
<li><p>标记-清除算法</p>
<p><strong>标记阶段，将所有存活的对象进行标记</strong>。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。</p>
<p><strong>清除阶段，从内存中删除没有被标记也就是非存活对象</strong>。</p>
</li>
<li><p>复制算法</p>
<p>准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。(<strong>不会发生碎片</strong>)</p>
</li>
<li><p>标记-整理算法(标记压缩算法)<strong>不会发生碎片化</strong></p>
<ol>
<li>标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。</li>
<li>整理阶段，<strong>将存活对象移动到堆的一端</strong>。清理掉存活对象的内存空间。</li>
</ol>
</li>
<li><p>分代收集算法</p>
<p><strong>将上述描述的垃圾回收算法组合进行使用</strong>,其中应用最广的就是分代垃圾回收算法(Generational GC)。分代垃圾回收将整个内存区域划分为两块大区：年轻代、老年代：</p>
<table>
<thead>
<tr>
<th>-Xms</th>
<th>设置堆的最小和初始大小，必须是1024倍数且大于1MB</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx</td>
<td>设置最大堆的大小，必须是1024倍数且大于2MB</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代的大小</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>伊甸园区和幸存区的比例，默认为8：如新生代有1g内存，则伊甸园区800MB，S0和S1各100MB</td>
</tr>
<tr>
<td>XX:+PrintGCDetailsverbose:gc</td>
<td>打印GC日志</td>
</tr>
</tbody></table>
<blockquote>
<p>老年代大小不需要设置，因为新生代设置完之后，老年代的大小就确定了（总的堆内存-新生代内存）</p>
</blockquote>
</li>
</ul>
<h3 id="1-3-垃圾回收器"><a href="#1-3-垃圾回收器" class="headerlink" title="1.3 垃圾回收器"></a>1.3 垃圾回收器</h3><ul>
<li><p>新生代可以适用的垃圾回收器：<strong>Serial(串行收集器)</strong>、<strong>ParNew(并行年轻代收集器)</strong>、<strong>Parallel Scavenge(并行回收器)</strong></p>
</li>
<li><p>老年代可以适用的垃圾回收器：<strong>CMS(并发标记-清除收集器)</strong>、<strong>Serial Old(串行老年代收集器)</strong>、<strong>Parallel Old(并行老年代收集器）</strong></p>
</li>
<li><p>**G1(Garbage First 收集器）<strong>和</strong>ZGC(Z Garbage Collector）**回收器适用于新生代和老年代混合回收</p>
</li>
</ul>
<h4 id="1-3-1-Serial-（读”色瑞洛“）和Serial-Old收集器"><a href="#1-3-1-Serial-（读”色瑞洛“）和Serial-Old收集器" class="headerlink" title="1.3.1 Serial （读”色瑞洛“）和Serial Old收集器"></a>1.3.1 Serial （读”色瑞洛“）和Serial Old收集器</h4><p><strong>暂停用户线程（Stop the World）：</strong><br>在开始垃圾收集过程之前，Serial 垃圾收集器会暂停（停止）所有的用户线程。这是为了确保在垃圾收集过程中对象的状态不会被修改，从而保证垃圾收集的准确性。<br><strong>执行垃圾收集：</strong><br>一旦用户线程暂停，Serial 垃圾收集器会开启一个单线程来执行垃圾回收操作。这个线程会遍历堆中的对象，标记并清理不再使用的对象，以释放内存空间。<br><strong>等待垃圾收集完成：</strong><br>在垃圾收集过程中，用户线程会被暂停，直到垃圾收集完毕。这意味着用户线程无法在垃圾收集期间执行任何操作。<br>恢复用户线程：<br>当垃圾收集完成后，Serial 垃圾收集器会恢复用户线程的执行。此时，垃圾已被清理，堆内存中有更多的可用空间供应用程序使用。</p>
<blockquote>
<p><strong>注：</strong><br>收集区域： Serial （新生代），Serial Old（老年代）<br>使用算法： Serial （标记复制法），Serial Old（标记整理法）<br>搜集方式： 单线程收集</p>
</blockquote>
<h4 id="1-3-2-Parallel（读”趴儿郎“）-Scavenge-（读”时嘎文级“）和-Parallel-Old收集器"><a href="#1-3-2-Parallel（读”趴儿郎“）-Scavenge-（读”时嘎文级“）和-Parallel-Old收集器" class="headerlink" title="1.3.2 Parallel（读”趴儿郎“） Scavenge （读”时嘎文级“）和 Parallel Old收集器"></a>1.3.2 Parallel（读”趴儿郎“） Scavenge （读”时嘎文级“）和 Parallel Old收集器</h4><p>**多线程并行执行：**Parallel Scavenge 收集器利用了多个线程并行执行新生代的垃圾回收操作。这意味着在进行新生代垃圾回收时，多个线程同时工作，加快了垃圾收集的速度。<br>**暂停用户线程：**与 Serial 收集器类似，Parallel Scavenge 在进行垃圾收集时会暂停用户线程，以确保垃圾回收的准确性。这一阶段通常称为“Stop the World”。<br>**多线程并发清理：**Parallel Scavenge 收集器的特点之一是在新生代垃圾收集过程中采用并行清理（Parallel Cleaning）的方式。这意味着在暂停用户线程期间，多个线程同时清理新生代中的垃圾对象，从而更快地完成垃圾收集过程。<br>高效利用多核 CPU：</p>
<blockquote>
<p><strong>注：</strong><br>收集区域： Parallel Scavenge （新生代），Parallel Old（老年代）<br>使用算法： Parallel Scavenge （标记复制法），Parallel Old（标记整理法）<br>搜集方式： 多线程</p>
</blockquote>
<h4 id="1-3-3-ParNew-（读”趴儿new“）收集器"><a href="#1-3-3-ParNew-（读”趴儿new“）收集器" class="headerlink" title="1.3.3  ParNew （读”趴儿new“）收集器"></a>1.3.3  ParNew （读”趴儿new“）收集器</h4><p>**停止应用程序线程（Stop the World）：**在进行垃圾收集之前，ParNew 收集器会暂停所有的用户线程。这一阶段被称为停止应用程序线程，以确保在垃圾收集过程中对象的状态不会被修改，保证垃圾回收的准确性。<br>**多线程并行执行垃圾收集：**一旦应用程序线程暂停，ParNew 收集器会启动多个线程并行执行垃圾回收操作。这些线程会同时在新生代中扫描和清理不再使用的对象，以释放内存空间。<br>**暂停用户线程：**在整个垃圾收集过程中，用户线程会一直处于暂停状态，直到垃圾收集完成。这个阶段也被称为“Stop the World”，在此期间应用程序无法执行任何操作。<br>**恢复用户线程：**当垃圾收集完成后，ParNew 收集器会恢复用户线程的执行。此时，垃圾已经被清理，堆中的内存空间得到了释放，用户线程可以继续执行。</p>
<blockquote>
<p><strong>注：</strong><br>收集区域： 新生代<br>使用算法： 标记复制法<br>搜集方式： 多线程。</p>
</blockquote>
<h4 id="1-3-4-CMS收集器（重点）"><a href="#1-3-4-CMS收集器（重点）" class="headerlink" title="1.3.4 CMS收集器（重点）"></a>1.3.4 CMS收集器（重点）</h4><p>CMS（Concurrent Mark-Sweep）垃圾收集器为了<strong>尽量减少用户线程的停顿时间</strong>，采用了一种创新的策略。这一策略使得在垃圾回收过程的某些阶段，用户线程和垃圾回收线程可以共同工作，从而避免了长时间的垃圾回收导致用户线程一直处于等待状态。</p>
<p>整个 CMS 垃圾收集过程被划分为四个阶段，它们分别是：</p>
<p><strong>1.初始标记{需要stw}（Initial Mark）</strong>：在这个阶段，CMS 垃圾收集器会对根对象进行一次快速的标记，标记出所有与根对象直接关联的存活对象。这个阶段需要暂停用户线程，因为要确保标记的准确性。<br>**2.并发标记（Concurrent Mark）：**在这个阶段，CMS 垃圾收集器会与用户线程并发执行，对整个堆进行标记。垃圾回收线程会在后台标记所有存活对象，而用户线程可以继续执行，不受影响。<br>**3.重新标记{需要stw}（Remark）：**在并发标记阶段结束后，CMS 垃圾收集器会进行一次重新标记，来处理在并发标记阶段发生变化的对象。这个阶段需要暂停用户线程，以确保标记的准确性。<br>**4.并发清理（Concurrent Sweep）：**在重新标记完成后，CMS 垃圾收集器会与用户线程并发执行，清理未标记的对象。垃圾回收线程会在后台清理不再使用的对象，而用户线程可以继续执行，不受影响。</p>
<blockquote>
<p><strong>注：</strong><br>收集区域： 老年代<br>使用算法： 标记清除法+标记整理法<br>搜集方式： 多线程</p>
</blockquote>
<h4 id="1-3-5-G1收集器（重点）"><a href="#1-3-5-G1收集器（重点）" class="headerlink" title="1.3.5 G1收集器（重点）"></a>1.3.5 G1收集器（重点）</h4><p>G1 垃圾收集器摒弃了传统的物理分区方式，而是将整个内存分成若干个大小不同的 Region了（泪颈）区域。每个 Region 在逻辑上组合成各个分代，这样做的好处是可以以 Region 为单位进行更细粒度的垃圾回收。G1 垃圾收集器在进行垃圾回收时，可以针对单个或多个 Region 进行回收，从而提高了收集效率和性能。</p>
<p>G1 垃圾收集器吸取了 CMS 垃圾收集器的优良思路，并通过摒弃物理分区、采用 Region 分区的方式，实现了更细粒度的垃圾回收，从而提高了整个系统的性能和可用性。 G1 垃圾收集器在大内存环境下的表现更加出色，成为了现代 Java 应用中的重要选择。<br>Region（局部收集）</p>
<p>G1 垃圾收集器的最核心分区基本单位是 Region。与传统的垃圾收集器不同，G1 不再将堆内存划分为固定连续的几块区域，而是完全舍弃了物理分区，而是将堆内存拆分成大小为 1MB 到 32MB 的 Region 块。然后，以 Region 为单位自由地组合成新生代、老年代、Eden 区、Survivor 区和大对象区（Humongous Region）等。随着垃圾回收和对象分配的进行，每个 Region 也不会一直固定属于某个分代，它们可以随时扮演任何一个分代区域的内存角色。</p>
<p>Collect Set（智能收集）</p>
<p>在G1里面会维护一个Collect Set集合。这个集合记录了待回收的 Region 块的信息，包括每个 Region 块可回收的大小空间。有了这个 CSet 信息，G1 在进行垃圾收集时可以根据用户设定的可接受停顿时间来进行分析，找出在设定的时间范围内收集哪些区域最划算，然后优先收集这些区域。这样做不仅可以优先收集垃圾最多的 Region，还可以根据用户的设定来计算收集哪些 Region 可以达到用户所期望的垃圾收集时间。</p>
<p>通过 CSet，G1 垃圾收集器的性能得到了极大的提升，并且能够实现可预测的停顿时间要求。这使得垃圾回收过程变得更加智能化，更加适应不同的应用场景和用户需求。需要注意的是，用户设定的时间应该合理，官方建议在 100ms 到 300ms 之间，以平衡垃圾收集的效率和停顿时间的需求。</p>
<p>**1.初始标记{需要stw}（Initial Mark）：**在初始标记阶段，G1 垃圾收集器会对根对象进行一次快速的标记，标记出所有与根对象直接关联的存活对象。这个阶段需要暂停用户线程，以确保标记的准确性。<br>**2.并发标记（Concurrent Mark）：**在并发标记阶段，G1 垃圾收集器会与用户线程并发执行，对整个堆进行标记。垃圾回收线程会在后台标记所有存活对象，而用户线程可以继续执行，不受影响。<br>**3.重新标记{需要stw}（Remark）：**在并发标记阶段结束后，G1 垃圾收集器会进行一次重新标记，来处理在并发标记阶段发生变化的对象。这个阶段需要暂停用户线程，以确保标记的准确性。<br>**4.筛选清除（Concurrent Cleanup）：**在重新标记完成后，G1 垃圾收集器不会立即进行整体的清除操作。相反，它会根据用户设置的停顿时间智能地筛选出需要回收的 Region，并执行局部的回收。这样可以在尽量满足停顿时间的情况下，最大限度地回收垃圾。</p>
<blockquote>
<p><strong>注：</strong><br>收集区域： 整个堆内存<br>使用算法： 标记复制法<br>搜集方式： 多线程</p>
</blockquote>
<h4 id="1-3-6-ZGC"><a href="#1-3-6-ZGC" class="headerlink" title="1.3.6 ZGC"></a>1.3.6 ZGC</h4><p>ZGC 的垃圾回收过程几乎全部都是并发执行的，即与应用程序线程同时进行。</p>
<p>**1.初始标记（Initial Mark）：**在初始标记阶段，ZGC 会标记出根对象以及直接与根对象关联的存活对象。这个阶段需要短暂地暂停所有应用线程，以确保标记的准确性。<br>**2. 并发标记（Concurrent Mark）：**在并发标记阶段，ZGC 与应用程序线程并发执行，标记所有存活对象。这个阶段不会暂停应用程序线程，因此垃圾回收和应用程序可以并发执行。<br>**3. 最终标记（Final Mark）：**在并发标记阶段结束后，ZGC 需要再次短暂地暂停所有应用线程，完成最终的标记工作。这个阶段主要用于标记在并发标记阶段有可能发生变化的对象。<br>**4. 筛选（Concurrent Sweep）：**在最终标记完成后，ZGC 会进行一次筛选，确定哪些对象可以被回收。这个阶段会并发地进行，不会暂停应用程序线程。<br>**5. 并发清除（Concurrent Cleanup）：**在筛选阶段完成后，ZGC 会并发地清除未被标记的对象，释放它们所占用的内存。这个阶段也不会暂停应用程序线程。</p>
<blockquote>
<p><strong>注：</strong><br>收集区域： 整个堆内存<br>使用算法： 并发标记法<br>搜集方式： 多线程</p>
</blockquote>
<h3 id="1-4-三色标记"><a href="#1-4-三色标记" class="headerlink" title="1.4  三色标记"></a>1.4  三色标记</h3><p>三色标记是根据可达性分析算法，从GC ROOTs开始进行遍历访问，按照“是否检查过”这个条件将对象标记为三种颜色：</p>
<p>**黑色：**代表这个对象已经检查过并且成员变量也检查过了</p>
<p>**灰色：**代表这个对象以及检查过，但是成员还没有检查完成。</p>
<p>**白色：**代表对象没有被检查，若在分析结束之前对象是白色的，即代表对象不可达</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><ol>
<li><p>初始将所有对象放在白色集合中（所有对象都置为白色）</p>
</li>
<li><p>将由GC ROOTS直接引用的对象挪到灰色集合中；</p>
</li>
<li><p>从灰色集合中获取对象：</p>
<p>3.1 将其本对象引用的其他对象放到灰色集合中；</p>
<p>3.2 将本对象放到黑色集合中；</p>
</li>
<li><p>重复以上步骤直到灰色集合为空</p>
</li>
<li><p>结束时白色集合的对象为不可达。可以进行回收</p>
</li>
</ol>
<p><strong>需要注意：传统标记方式发送stop the World时，对象之间的引用不会发生变化。但是在并发标记期间，对象之间的引用可能发生变化会出现错标，漏标等情况</strong></p>
<h4 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h4><p>标过不是垃圾的（回收或者黑色）突然变成了垃圾。此时该对象不会被清除，会在下一次的GC中清除。</p>
<h4 id="对象漏标问题：需要的对象被回收"><a href="#对象漏标问题：需要的对象被回收" class="headerlink" title="对象漏标问题：需要的对象被回收"></a>对象漏标问题：需要的对象被回收</h4><p>一个从未被扫描到的对象在标记的过程中被黑色对象引用了，但由于此对象是白色会被回收会导致出现系统问题。</p>
<h3 id="1-5-内存泄漏和内存溢出的区别"><a href="#1-5-内存泄漏和内存溢出的区别" class="headerlink" title="1.5 内存泄漏和内存溢出的区别"></a>1.5 内存泄漏和内存溢出的区别</h3><p>内存泄漏：程序未能释放不再使用的对象或者内存，导致内存浪费。例如死锁，死循环，未能再try-catch-finally中的finally释放资源</p>
<p>内存溢出（OOM）：内存分配超过了jvm分配的内存上限。</p>
<h3 id="1-6-对象的结构是什么样的"><a href="#1-6-对象的结构是什么样的" class="headerlink" title="1.6 对象的结构是什么样的"></a>1.6 对象的结构是什么样的</h3><ol>
<li><p><strong>对象头</strong></p>
<p>1.1<strong>Mark word</strong></p>
<p>存储资深的运行数据例如：哈希码（hashcode）、GC分代年龄、锁状态标识、线程持有的锁、偏向线程id等</p>
<p>1.2 <strong>Class pointer（类型指针）</strong></p>
<p>指向对象的类元数据（Class Metadata），JVM通过它来确定改对象是那个类的实例，并据此找到该类的方法区</p>
<p>1.3 <strong>数组长度</strong></p>
</li>
<li><p><strong>实例数据</strong></p>
<p>存储实体类的实例字段内容，包括从父类继承的数据</p>
</li>
<li><p><strong>对齐填充</strong></p>
</li>
</ol>
<p>JVM要求对象的起始地址是8字节的整数倍</p>
<h3 id="1-7-类加载流程和双亲委派"><a href="#1-7-类加载流程和双亲委派" class="headerlink" title="1.7 类加载流程和双亲委派"></a>1.7 类加载流程和双亲委派</h3><p>java的类加载机制与双亲委派模型是java虚拟机加载类文件的一种体系结构，用于保证java应用程序中类的单一性，安全性和加载顺序。</p>
<p>类加载器机制：</p>
<p>Bootstrap ClassLoader：引导类加载器，负责加载核心java库，由jvm自己实现（如rt.jar）</p>
<p>Extension ClassLoader: 扩展类加载器，加载扩展类库，通常从java。ext。dirs系统属性指定的目录中加载，</p>
<p>Application ClassLoader：系统类加载器。加载用户类路径（classpath）中定义的类。</p>
<p>双亲委派模型</p>
<p>当一个类接收到类加载请求的时候会先请求父类的加载器去加载，只有当父类的加载器无法加载的时候才有子类的子加载器去加载。</p>
<h3 id="二、spring面试题"><a href="#二、spring面试题" class="headerlink" title="二、spring面试题"></a>二、spring面试题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">熟练运用 Spring(IOC，AOP，三级缓存，Bean的生命周期)，、Mybatis/Mybatis Plus、Spring Boot等开源框架。</span><br></pre></td></tr></table></figure>

<h3 id="2-1-ioc的执行流程"><a href="#2-1-ioc的执行流程" class="headerlink" title="2.1 ioc的执行流程"></a>2.1 ioc的执行流程</h3><p><strong>1. ioc是什么</strong></p>
<p>ioc的全称是（inversion of control）控制反转，其核心思想是把对象的管理权限交给容器，降低程序之间的耦合性，使程序更加灵活。</p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241022173317423.png" alt="image-20241022173317423"></p>
<p><strong>DI（Dependency Injection），即依赖注入</strong></p>
<p>由 Martin Fowler 提出。可以认为 IoC 和 DI 其实是同一个概念的不同角度描述。</p>
<p>依赖注入是指组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</p>
<p>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p><strong>2. bean的声明方式</strong></p>
<p>例如在xml配置文件里面通过bean的标签、通过@service注解、通过@Configuration注解里面的@Bean注解，</p>
<p>spring在启动的时候会解析这些bean然后保存到ioc容器里面。</p>
<p><strong>3、BeanDefinition</strong></p>
<p>理解了 bean，BeanDefinition 就好理解了。BeanDefinition 是 bean 的定义，用来存储 bean 的所有属性方法定义。</p>
<p><strong>4、BeanFactory 和 ApplicationContext</strong></p>
<p>BeanFactory：基础类型 IoC 容器，提供完整的 IoC 服务支持。</p>
<p>ApplicationContext：BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory 的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext。</p>
<p><strong>5、FactoryBean</strong></p>
<p>一般情况下，我们将 bean 的创建和管理都交给 Spring IoC 容器，Spring 会利用 bean 的 class 属性指定的类来实例化 bean。</p>
<p>但是如果我们想自己实现 bean 的创建操作，可以实现吗？答案是可以的，FactoryBean 就可以实现这个需求。</p>
<p>FactoryBean 是一种特殊的 bean，它是个工厂 bean，可以自己创建 bean 实例，如果一个类实现了 FactoryBean 接口，则该类可以自己定义创建实例对象的方法，只需要实现它的 getObject() 方法即可。</p>
<p><strong>5. ioc的工作流程</strong></p>
<ol>
<li><p>ioc容器的初始化阶段</p>
<p>根据程序里面定义的xml或者注解的@Bean等声明方式通过解析和加载后生成BeanDefinition，然后把BeanDefinition注册到ioc容器里面。通过xml或者注解的@Bean等声明Bean都会解析得到BeanDefinition实体。然后保存在一个map集合，从而完成idc的初始化。</p>
</li>
<li><p>完成Bean的初始化和依赖注入</p>
<p>通过反射去给没有设置lazy-init属性的单例Bean进行初始化，第二个是完成Bean的依赖注入。</p>
</li>
<li><p>bean的使用</p>
<p>通过@Autowired注解或者BeanFactory.getBean（）从ioc容器获取一个指定的实例。对于设置了lazy-init属性和非单例Bean的实例化。是在每次获取Bean对象的时候进行调用Bean的初始化来完成实例化的，并且springioc容器不会去管理这些Bean。</p>
</li>
</ol>
<h3 id="2-2-讲一讲-spring-AOP"><a href="#2-2-讲一讲-spring-AOP" class="headerlink" title="2.2 讲一讲 spring-AOP"></a>2.2 讲一讲 spring-AOP</h3><h4 id="2-2-1-请谈一下springAop的理解"><a href="#2-2-1-请谈一下springAop的理解" class="headerlink" title="2.2.1 请谈一下springAop的理解"></a>2.2.1 请谈一下springAop的理解</h4><p>springAop是面向切面编程，实现横切逻辑的控制，例如spring的事务控制，日志，权限控制，限流</p>
<h4 id="2-2-2-谈一下springAop的原理"><a href="#2-2-2-谈一下springAop的原理" class="headerlink" title="2.2.2 谈一下springAop的原理"></a>2.2.2 谈一下springAop的原理</h4><p>动态代理jdk和CGLIB</p>
<h4 id="2-2-3-springAop使用了那种动态代理"><a href="#2-2-3-springAop使用了那种动态代理" class="headerlink" title="2.2.3 springAop使用了那种动态代理"></a>2.2.3 springAop使用了那种动态代理</h4><p>如果是接口的实现方式，使用的是默认的jdk，没有实现接口的话就是CHLIB</p>
<h4 id="2-2-4-jdk和CGLIB有什么区别"><a href="#2-2-4-jdk和CGLIB有什么区别" class="headerlink" title="2.2.4 jdk和CGLIB有什么区别"></a>2.2.4 jdk和CGLIB有什么区别</h4><p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241022235744956.png" alt="image-20241022235744956"></p>
<h3 id="2-3-三级缓存"><a href="#2-3-三级缓存" class="headerlink" title="2.3 三级缓存"></a>2.3 三级缓存</h3><p>1级：单例bean的池map对象</p>
<p>2级：动态代理对象</p>
<p>3级：创建动态代理需要的函数式接口</p>
<p><strong>实例化—-&gt;缓存bean的实例和bean的名字也就是通过函数时接口将lambda表达式传递进去进行缓存—–&gt;属性赋值———-&gt;调用dogetBean（B）若没有就调用docreatedBean区创建另外一个实例，在这个实例中需要A的Bean，—–&gt;先去按照一级二级三级缓存区找，若一二级都没有—–&gt;在三级缓存中拿到这个lambda表达式，然后利用这个lambda创建代理对象将其存入二级缓存</strong></p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024143845394.png" alt="image-20241024143845394"></p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024143932862.png" alt="image-20241024143932862"></p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024144010001.png" alt="image-20241024144010001"></p>
<p><img src="C:\Users\emc\AppData\Roaming\Typora\typora-user-images\image-20241024144916448.png" alt="image-20241024144916448"></p>
<h2 id="三、mybatis的面试题"><a href="#三、mybatis的面试题" class="headerlink" title="三、mybatis的面试题"></a>三、mybatis的面试题</h2><h3 id="3-1-mybatis是怎么分页的"><a href="#3-1-mybatis是怎么分页的" class="headerlink" title="3.1 mybatis是怎么分页的"></a>3.1 mybatis是怎么分页的</h3><p>三种方式：</p>
<ol>
<li>直接使用数据库的关键字limit</li>
<li>使用mybatis提供的RowBounds对象，实现内存级别分页</li>
<li>基于mybatis里面的interceptor拦截器在select语句执行之前动态拼接分页关键字</li>
</ol>
<h3 id="3-2-mybatis的-和-的区别"><a href="#3-2-mybatis的-和-的区别" class="headerlink" title="3.2 mybatis的#{}和$的区别"></a>3.2 mybatis的#{}和$的区别</h3><p>#可以实现预编译，会先把#{变量}编译成?，在执行时再取值，可以防止sql注入。</p>
<p>$是直接进行字符串替换。适用于去执行动态的人工生成的sql</p>
<h3 id="3-3-mybatis的缓存你知道吗"><a href="#3-3-mybatis的缓存你知道吗" class="headerlink" title="3.3 mybatis的缓存你知道吗"></a>3.3 mybatis的缓存你知道吗</h3><p>一级缓存是SqlSession级别的缓存，它默认是开启的。当同一个SqlSession执行相同的SQL语句 时，会先从缓存中查找，如果找到了对应的结果，则直接返回缓存中的结果，而不会再次访问数据库。</p>
<p>二级缓存是Mapper级别的缓存，它默认是关闭的。作用域在SqlSessionFaction，当不同的SqlSession执行相同的SQL语句时，如果开启了二级缓存，则会先从缓存中查找，如果找到了对应的结果，则直接返回缓存中的结果，而不会 再次访问数据库。</p>
<h3 id="3-4-SqlSession为什么是数据不安全的？"><a href="#3-4-SqlSession为什么是数据不安全的？" class="headerlink" title="3.4 SqlSession为什么是数据不安全的？"></a>3.4 SqlSession为什么是数据不安全的？</h3><p>在MyBatis中，SqlSession是一个线程不安全的对象，主要原因如下：</p>
<ol>
<li>SqlSession的底层实现是基于JDBC的Connection对象，而Connection对象是非线程安全的，因此 SqlSession也是非线程安全的。 </li>
<li>SqlSession中包含了数据库连接和事务相关的操作，如果多个线程共享同一个SqlSession实例，可 能会导致数据的  不一致性或者  事务的混乱。</li>
<li>SqlSession中的  缓存机制也是基于当前线程的，如果多个线程共享同一个SqlSession实例，可能会 导致缓存的数据混乱或者不一致。</li>
</ol>
<p>**如何解决这个问题？ **</p>
<p>为了保证数据的安全性和一致性，通常建议在每个线程中使用独立的SqlSession实例，可以通过工 厂模式创建新的SqlSession对象，或者使用MyBatis提供的线程安全的SqlSessionFactory实例来创建 SqlSession。另外，可以使用ThreadLocal来保证每个线程中使用的SqlSession对象是唯一的。</p>
<h2 id="四、springboot的面试题"><a href="#四、springboot的面试题" class="headerlink" title="四、springboot的面试题"></a>四、springboot的面试题</h2><h3 id="4-1-springboot的自动配置原理-重点"><a href="#4-1-springboot的自动配置原理-重点" class="headerlink" title="4.1  springboot的自动配置原理(重点)"></a>4.1  springboot的自动配置原理(重点)</h3><ol>
<li><strong>通过@SpringBootConfiguration 引入了@EnableAutoConfiguration (负责启动自动配置功能）</strong></li>
<li><strong>@EnableAutoConfiguration 引入了@Import</strong></li>
<li><strong>Spring容器启动时：加载Ioc容器时会解析@Import 注解</strong></li>
<li>**@Import导入了一个deferredImportSelector{延时加载}(它会使SpringBoot的自动配置类的顺序在最后，这样方便我们扩展和覆盖？) **</li>
<li>**然后读取所有的&#x2F;META-INF&#x2F;spring.factories文件（伪SPI) **</li>
<li>**过滤出所有AutoConfigurtionClass类型的类 **</li>
<li><strong>最后通过@ConditioOnXXX排除无效的自动配置类</strong></li>
<li><strong>对于满足条件的自动配置类，Spring Boot会创建并注册其中的Bean到Spring容器中。</strong></li>
<li><strong>应用配置这些Bean会携带默认的配置信息，并在项目运行时被自动应用到相应的组件上。</strong></li>
</ol>
<h3 id="4-2-为什么springboot的jar可以直接运行？"><a href="#4-2-为什么springboot的jar可以直接运行？" class="headerlink" title="4.2 为什么springboot的jar可以直接运行？"></a>4.2 为什么springboot的jar可以直接运行？</h3><p>回答：通过这个spring-boot-maven-plugin插件打包之后会生成Fat jar，而，这里面包含程序依赖的jar包和自己写的代码的jar包</p>
<p>然后执行java -jar之后会找到jar中的manifest文件找到启动类Main-class，然后这个启动类会找到start-class然后以一个新的线程去执行。</p>
<ol>
<li>SpringBoot提供了一个插件spring-boot-maven-plugin用于把程序打包成一个可执行的jar包。 </li>
<li>Spring Boot应用打包之后，生成一个Fat jar(jar包中包含jar)，包含了应用依赖的jar包和Spring Boot loader相关的 类。</li>
<li>java -jar会去找jar中的manifest文件，在那里面找到真正的启动类（Main-Class）；</li>
<li>Fat jar的启动Main函数是JarLauncher，它负责创建一个自定义的类加载器LaunchedURLClassLoader来加载boot-lib下面的jar，并以 一个新线程启动应用的启动类的Main函数（找到manifest中的Start-Class）。</li>
</ol>
<h3 id="4-3-SpringBoot的启动原理？（重点）"><a href="#4-3-SpringBoot的启动原理？（重点）" class="headerlink" title="4.3 SpringBoot的启动原理？（重点）"></a>4.3 SpringBoot的启动原理？（重点）</h3><ol>
<li><p>运行main方法： 初始化new SpringApplication 从spring.factories 读取 listener ApplicationContextInitializer  </p>
</li>
<li><p>运行run方法</p>
</li>
<li><p>读取 环境变量  配置信息….</p>
</li>
<li><p>创建springApplication上下文:ServletWebServerApplicationContext</p>
</li>
<li><p>预初始化上下文 ： 将启动类作为配置类进行读取–&gt;将配置注册为BeanDefinition </p>
</li>
<li><p>调用refresh 加载ioc容器</p>
<p>​    invokeBeanFactoryPostProcessor – 解析@Import: 加载所有的自动配置类 </p>
<p>​    onRefresh 创建(内置)servlet容器 </p>
</li>
<li><p>在这个过程中springboot会调用很多监听器</p>
</li>
</ol>
<h2 id="五、数据库mysql面试题"><a href="#五、数据库mysql面试题" class="headerlink" title="五、数据库mysql面试题"></a>五、数据库mysql面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深入理解MySQL底层原理，对于MySQL索引(索引失效，索引覆盖)、事务机制(ACID，MVCC)有一定的研究，对SQL调优有一定了解，了解mysql的分库分表以及sharding-jdbc的实现。</span><br></pre></td></tr></table></figure>

<h3 id="5-1-数据库三大范式是什么"><a href="#5-1-数据库三大范式是什么" class="headerlink" title="5.1 数据库三大范式是什么"></a>5.1 <strong>数据库三大范式是什么</strong></h3><p>第一范式：每个列都不可以再拆分。 </p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。 </p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<blockquote>
<p> 在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我 们经常会为了性能而妥协数据库的设计。</p>
</blockquote>
<h3 id="5-2-mysql有关权限的表都有哪几个"><a href="#5-2-mysql有关权限的表都有哪几个" class="headerlink" title="5.2 mysql有关权限的表都有哪几个"></a>5.2 mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由 mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分 别介绍一下这些表的结构和内容：</p>
<p><strong>user权限表</strong>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。 </p>
<p><strong>db权限表</strong>：记录各个帐号在各个数据库上的操作权限。 </p>
<p>**table_priv权限表：**记录数据表级的操作权限。</p>
<p>**columns_priv权限表：**记录数据列级的操作权限。 </p>
<p>**host权限表：**配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和 REVOKE语句的影响。</p>
<h3 id="5-3-MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#5-3-MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="5.3 MySQL的binlog有有几种录入格式？分别有什么区别？"></a>5.3 MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>有三种格式，statement，row和mixed。 statement模式下，每一条会修改数据的sql都会记录在binlog中。</p>
<ul>
<li><strong>statement</strong> 不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。 </li>
<li><strong>row级别下</strong>，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动， 基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如altertable)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li><strong>mixed</strong>，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。 此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录</li>
</ul>
<h3 id="5-4-MySQL存储引擎"><a href="#5-4-MySQL存储引擎" class="headerlink" title="5.4 MySQL存储引擎"></a>5.4 MySQL存储引擎</h3><p><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID<strong>事务</strong>的支持。并且还提供了<strong>行级锁</strong>和<strong>外键</strong>的约束。它的设计的目标就是处理大数据容量的数据库系统。</p>
<p> **MyIASM引擎(原本Mysql的默认引擎)：**不提供事务的支持，也不支持行级锁和外键。 </p>
<p><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高</p>
<h3 id="5-5-mysql的索引有哪些"><a href="#5-5-mysql的索引有哪些" class="headerlink" title="5.5 mysql的索引有哪些"></a>5.5 mysql的索引有哪些</h3><p>**主键索引:**数据列不允许重复，不允许为NULL， 一个表只能有一个主键。 </p>
<p>**唯一索引:**数据列不允许重复，允许为NULL值， 一个表允许多个列创建唯一索引。 可以通过ALTERTABLEtable_nameADDUNIQUE(column); 创建唯一索引 可以通过ALTERTABLEtable_nameADDUNIQUE(column1,column2); 创建唯一组合索引 </p>
<p>**普通索引:**基本的索引类型，没有唯一性的限制，允许为NULL值。 可以通过ALTERTABLEtable_nameADDINDEXindex_name(column); 创建普通索引 可以通过ALTERTABLEtable_nameADDINDEXindex_name(column1,column2,column3); 创建组合索引 </p>
<p>**全文索引：**是目前搜索引擎使用的一种关键技术。 可以通过ALTERTABLEtable_nameADDFULLTEXT(column); 创建全文索引</p>
<h3 id="5-6-索引的底层"><a href="#5-6-索引的底层" class="headerlink" title="5.6 索引的底层"></a>5.6 索引的底层</h3><p>B+tree</p>
<ol>
<li>非叶子节点不存数据，只存索引</li>
<li>叶子节点村索引值并且叶子节点使用双向链表，保证范围查询</li>
</ol>
<p>哈希索引</p>
<p>类似于数据结构中简单实现的HASH表（散列表）一样，当我们在 mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠 法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入 Hash表的对应位置；如果发生 Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<h3 id="5-7-索引设计的原则？"><a href="#5-7-索引设计的原则？" class="headerlink" title="5.7 索引设计的原则？"></a>5.7 索引设计的原则？</h3><p>1.适合索引的列是出现在where子句中的列，或者连接子句中指定的列</p>
<p> 2.基数较小的类，索引效果较差，没有必要在此列建立索引 </p>
<p>3.使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间 </p>
<p>4.不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<h3 id="5-8-什么是最左前缀原则？"><a href="#5-8-什么是最左前缀原则？" class="headerlink" title="5.8 什么是最左前缀原则？"></a>5.8 什么是最左前缀原则？</h3><p>什么是最左匹配原则  顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like) 就停止匹配，比如a&#x3D;1andb&#x3D;2andc&gt;3andd&#x3D;4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建 立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 &#x3D;和in可以乱序，比如a&#x3D;1andb&#x3D;2andc&#x3D;3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化 成索引可以识别的形式</p>
<h3 id="5-9-事物的四大特性-ACID-介绍一下"><a href="#5-9-事物的四大特性-ACID-介绍一下" class="headerlink" title="5.9 事物的四大特性(ACID)介绍一下?"></a>5.9 事物的四大特性(ACID)介绍一下?</h3><p>关系性数据库需要遵循ACID规则，具体内容如下</p>
<ul>
<li>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该 对其有任何影响。</li>
</ul>
<p><strong>什么是脏读？幻读？不可重复读？</strong>  </p>
<ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前 一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 </li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这 可能是两次查询过程中间插入了一个事务更新的原有的数据。 </li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数 据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据 是它先前所没有的。</li>
</ul>
<p><strong>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</strong></p>
<p> 为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为</p>
<p>Read  uncommitted、Read committed、Repeatable read、Serializable，</p>
<p>这四个级别可以逐个解决脏读、 不可重复读、幻读这几类问题。默认是RR， Oracle默认采用RC</p>
<blockquote>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读已提交):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。 InnoDB 存储引擎在分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</p>
</blockquote>
<h3 id="5-10-锁"><a href="#5-10-锁" class="headerlink" title="5.10 锁"></a>5.10 锁</h3><h4 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1. 全局锁"></a>1. 全局锁</h4><p>当执行数据库备份的时候会使用</p>
<h4 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2. 表级锁"></a>2. 表级锁</h4><p>表读锁：表共享读锁，允许读，不允许写</p>
<p>表行锁：表排他写锁，读写都不可以</p>
<p>意向锁，加行锁的时候会自动添加意向锁，</p>
<h4 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3. 行级锁"></a>3. 行级锁</h4><p>读锁，行共享读锁</p>
<p>写锁，行排他写锁</p>
<p>间隙锁：锁定一个范围，不包括记录本身</p>
<p>临建锁： 锁定一个范围，包含记录本身</p>
<p><strong>数据库的乐观锁和悲观锁是什么？怎么实现的？</strong></p>
<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并 发控制主要采用的技术手段。 </p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁 起来，直到提交事务。</p>
<p>乐观锁：使用数据库中的锁机制乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。 两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较</p>
<h3 id="5-11-mvcc"><a href="#5-11-mvcc" class="headerlink" title="5.11 mvcc"></a>5.11 mvcc</h3><p>多并发版本控制器、通俗点就是一种并发控制的方法，一般用于数据库中对数据库的并发访问。Mysql中的innoDB中就是使用这种方法来提高读写事务控制的、他大大提高了读写事务的并发性能，原因是MVCC是一种不采用锁来控制事物的方式，是一种非堵塞、同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。</p>
<p><strong>前言</strong></p>
<p>数据库创建表的时候会有2-3个隐藏字段（若没有主键会自动添加一个主键）隐藏字段</p>
<ol>
<li>记录当前事务id的DB_TRX_ID</li>
<li>用来记录上一个版本数据记录的回滚指针</li>
</ol>
<p><strong>实现原理+回答</strong>（回答乐观锁的体现cas）</p>
<p><strong>MVCC的实现原理是依靠记录中的2-3个隐含字段当前事务id和回滚指针、undo log日志、Read View（快照读）来实现的。根据当前事务id和回滚指针会形成一个版本链，在RC是每次快照读时都会产生新的快照和Read View、所以就会产生不可重复读问题。而RR只会在第一次查询生成快照读。</strong></p>
<p><strong>undo log日志分为两种</strong></p>
<p>insert undo log：事务进行插入操作时产生、在事务回滚时需要，提交事务后可以被立即丢弃。<br>update undo log：进行update、delete时产生的undo log、不仅在回滚事务时需要、在快照读时也需要。所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
<p><strong>Read View(快照读)</strong></p>
<p>read view读视图就是在进行快照读时会产生一个read view视图、在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)。</p>
<ul>
<li>RR创建一个快照和Read View并且下次快照读时使用的还是同一个Read View所以其他事务修改数据对他是不可见的、解决了不可重复读问题。</li>
<li>RC则是每次快照读时都会产生新的快照和Read View、所以就会产生不可重复读问题。</li>
</ul>
<h3 id="5-11-索引失效的场景"><a href="#5-11-索引失效的场景" class="headerlink" title="5.11 索引失效的场景"></a>5.11 索引失效的场景</h3><ul>
<li>不满住最左匹配原则</li>
<li>索引列有计算</li>
<li>索引使用了函数</li>
<li>字段类型不同或者存在类型转换</li>
<li>左%模糊查询（解决：加一个字段为这个存这个字段的相反字段）</li>
<li>使用or但是or两边有一边没有使用索引</li>
<li>使用not关键字</li>
</ul>
<h3 id="5-12-索引覆盖"><a href="#5-12-索引覆盖" class="headerlink" title="5.12 索引覆盖"></a>5.12 索引覆盖</h3><p><strong>单列索升级为联合索引后，索引叶子节点存储了需要查询的索引字段而不需要走回表查询</strong></p>
<h3 id="5-13-索引下推"><a href="#5-13-索引下推" class="headerlink" title="5.13 索引下推"></a>5.13 索引下推</h3><p>如果没有索引下推，当进行索引查询的时候，首先根据索引来查找记录，然后再根据where条件过滤。</p>
<p>如果有索引下推，mysql在取出索引的同时会判断是否可以进行where条件过滤再进行索引查询们也就是先提前执行where的部分过滤操作，再某些场景会减少回表次数，提示性能。</p>
<h3 id="5-14-mysql-有哪几种日志"><a href="#5-14-mysql-有哪几种日志" class="headerlink" title="5.14 mysql 有哪几种日志"></a>5.14 mysql 有哪几种日志</h3><p>1：重做日志（redo log）</p>
<p>2：回滚日志（undo log）</p>
<p>3：二进制日志（binlog）</p>
<p>4：错误日志（errorlog）</p>
<p>5：一般查询日志（general log）</p>
<p>6：慢查询日志（slow query log）</p>
<p>7：中继日志（relay log）。</p>
<h3 id="5-15-mysql读写分离的过程"><a href="#5-15-mysql读写分离的过程" class="headerlink" title="5.15 mysql读写分离的过程"></a>5.15 mysql读写分离的过程</h3><p><strong>在写的数据库会将修改日志记录在binlog日志中，然后一段时间将其发送到写数据库，写数据库会将其保存在relay log日志中，然后写数据库会开启一个io线程去执行这个中继日志</strong></p>
<h3 id="5-16-sharding-jdbc"><a href="#5-16-sharding-jdbc" class="headerlink" title="5.16 sharding-jdbc"></a>5.16 sharding-jdbc</h3><p>这个自在网上看，这个属于分布式的知识，我还不太懂，只是在工作中稍微用到了一下。</p>
<h2 id="六、Redis-面试题"><a href="#六、Redis-面试题" class="headerlink" title="六、Redis 面试题"></a>六、Redis 面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">熟悉Redis缓存解决方案，数据结构(底层实现，应用场景)，持久化，一致性，缓存雪崩击穿、穿透(解决方案)，限流，以及如何使用Redis实现排行榜。</span><br></pre></td></tr></table></figure>

<h3 id="6-1-redis的底层数据结构以及他们的应用场景"><a href="#6-1-redis的底层数据结构以及他们的应用场景" class="headerlink" title="6.1 redis的底层数据结构以及他们的应用场景"></a>6.1 redis的底层数据结构以及他们的应用场景</h3><h4 id="6-1-1-key的底层存储方式：SDS-字节数组，字符串长度，未使用字节的数量"><a href="#6-1-1-key的底层存储方式：SDS-字节数组，字符串长度，未使用字节的数量" class="headerlink" title="6.1.1. key的底层存储方式：SDS(字节数组，字符串长度，未使用字节的数量)"></a>6.1.1. key的底层存储方式：SDS(字节数组，字符串长度，未使用字节的数量)</h4><p> redis是使用c语言写的，但它底层在存放redis的<code>key</code>时，并没有用c语言原生的字符串数据结构，而是定义了一个属于redis的数据结构<code>SDS</code>(Simple Dynamic String)，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">     <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">     <span class="comment">//等于 SDS 保存字符串的长度</span></span><br><span class="line">     <span class="type">int</span> len;</span><br><span class="line">     <span class="comment">//记录 buf 数组中未使用字节的数量</span></span><br><span class="line">     <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">     <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">     <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.二进制安全的数据结构<br>比如是操作命令是get aaa\0 ：获取 aaa\0的值。如果是c语言的字符数组就会把\0吞掉，变为get aaa，而使用SDS就会完整的操作aaa\0，SDS把所有接受到的数据都转成字符串，即使是一些特殊字符！<br>2.SDS提供了内存预分配机制，避免频繁的内存分配<br>如果是c语言，在修改一个key时，会分配一个新的字符数组，然后进行内存赋值，而SDS则采用预先分配机制，直接把字符串容量扩大两倍，key的长度变化时，直接在已分配的内存中修改即可，如果不够继续扩大2倍<br>3.兼容c语言的函数库<br>定制SDS数据结构并不是重复造轮子，该复用的还是要复用！</p>
<h4 id="6-1-2-string-使用场景"><a href="#6-1-2-string-使用场景" class="headerlink" title="6.1.2 string &amp;&amp; 使用场景"></a>6.1.2 string &amp;&amp; 使用场景</h4><ol>
<li><p>单值缓存<br>缓存对象的json格式</p>
</li>
<li><p>分布式锁</p>
<p>其中SETNX key value 命令要求如果key已存在，则其他的setnx命令无法对当前key进行操作。<br>SET product:10001 true ex 10 nx 命令设置key的超时时间，防治死锁！</p>
</li>
<li><p>计数器<br>INCR 文章id，全局唯一id<br>可以使用INCR命令实现数量自增，可以用于文章阅读量、热度人数统计等，用户每点进去一次执行一次INCR命令！</p>
</li>
<li><p>分布式系统全局序列号<br>在分布式系统下，如果需要分库分表， mysql的数据库自增id已经无法满足分库分表下的id自增，这时就需要一个独立于数据库之外的中间件来实现id的分配。</p>
</li>
<li><p>会话缓存，如session、token</p>
</li>
</ol>
<h4 id="6-1-3-hash"><a href="#6-1-3-hash" class="headerlink" title="6.1.3 hash"></a>6.1.3 hash</h4><p>同类数据归类整合储存，方便数据管理</p>
<p><strong>相比string操作消耗内存与cpu更小</strong><br>因为：string类型通过set key - val 的方式存储数据，通过对key进行hash运算决定当前key是存储在数组哪个位置。如果把hash类型的数据变成string类型来存储，则需要更多的key，同时在存放时也需要更多的hash(key)运算，消耗更多的cpu资源！</p>
<p><strong>相比string储存更节省空间</strong><br>如果把hash类型的数据变成string类型来存储，将需要存储更多key，如果数据量很多的情况下，redis底层那么存储数据的数组将很快会被占满，占满就会进行扩容，加大内存消耗。由此可见，string结构与hash结构只存储一个key相比，需要更多的内存空间！</p>
<h4 id="6-1-4-list"><a href="#6-1-4-list" class="headerlink" title="6.1.4 list"></a>6.1.4 list</h4><p>list类似一个队列或栈</p>
<h4 id="6-1-5-set-使用场景"><a href="#6-1-5-set-使用场景" class="headerlink" title="6.1.5 set &amp;&amp; 使用场景"></a>6.1.5 set &amp;&amp; 使用场景</h4><p>普通的集合（set）由借助哈希表存储数据，且value永远为null，类似于HashSet；而有序集合类似Redis集合，不同的是它的value存储的不再是null，而是记录权重的分数score（double）。</p>
<p>为了达到快速的顺序访问，它内部还维护了一个压缩列表（ziplist）或跳跃表(skiplist)。元素数量小时使用压缩列表实现以节省空间，当、元素数据变大超过阈值时则转为跳跃表，以此降低插入、删除和查找操作的复杂度（O(log N)）。</p>
<p>压缩列表和跳跃表都是用来维护排序信息，元素为哈希表的key数据，排序依据是key对应的score。</p>
<p>set是一个集合，key不允许重复，如果重复设置key，则设置无效，用于去求两个人的共同好友</p>
<p><strong>抽奖活动</strong></p>
<p>1）点击参与抽奖加入集合<br>SADD key {userlD}</p>
<p>2）查看参与抽奖所有用户<br>SMEMBERS key</p>
<p>3）随机抽取count名中奖者<br>SRANDMEMBER key [count] ——元素不从集合中删除<br>SPOP key [count] —— 元素从集合中删除<br><strong>朋友圈点赞</strong></p>
<p>点赞<br>SADD like:{消息ID} {用户ID}<br>取消点赞<br>SREM like:{消息ID} {用户ID}<br>检查用户是否点过赞<br>SISMEMBER like:{消息ID} {用户ID}<br>获取点赞的用户列表<br>SMEMBERS like:{消息ID}<br>获取点赞用户数<br>SCARD like:{消息ID}<br><strong>利用set的交、并、差集实现微博、微信关注模型</strong></p>
<p>首先了解一下set的集合操作，假如有三个集合<br>set1：（a、b、c）<br>set2：（b、c、d）<br>set3：（c、d、e）</p>
<p>三个集合的<br>交集为：SINTER set1 set2 set3 &#x3D;&#x3D;&gt; { c }<br>并集为：SUNION set1 set2 set3 &#x3D;&#x3D;&gt; { a,b,c,d,e }<br>差集为：SDIFF set1 set2 set3 &#x3D;&#x3D;&gt; { a }<br>差集计算方式：set1 - （set2并set3） &#x3D; {a、b、c} - {b、c、d、e} &#x3D; {a} 只保留a中单独存在的元素</p>
<p>共同关注A的人：可以用交集来实现<br>我可能认识的人：可以使用差集来实现，把我关注的人求差集<br>我关注的人也关注A：可以使用SISMEMBER 命令查看A是否在我关注的人的关注列表中，如果存在把这个人返回</p>
<h4 id="6-1-6-zset-使用场景"><a href="#6-1-6-zset-使用场景" class="headerlink" title="6.1.6 zset &amp;&amp; 使用场景"></a>6.1.6 zset &amp;&amp; 使用场景</h4><p><strong>zset有两种不同的实现方式：紧凑列表和跳表。</strong><br>在元素较少或总体元素占用空间较少时，使用紧凑列表实现。</p>
<p>在不符合使用紧凑列表的条件时，使用字典hash+跳表skiplist实现。</p>
<p><strong>跳表(SkipList)：增加了向前指针的链表叫作跳表。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</strong></p>
<p>zset相比于set多一个score 分值，正是根据这个分值进行排序，所以zset才能展示有序的数据，可以用来实现排行榜。</p>
<h3 id="6-2-redis的持久化"><a href="#6-2-redis的持久化" class="headerlink" title="6.2 redis的持久化"></a>6.2 redis的持久化</h3><ul>
<li>RDB（Persistence DB）：RDB类似快照，它只能持久化某一时刻的服务器数据。RDB持久化后，文件将被保存至同文件夹下的dump.rdb文件中，且以压缩的二进制文件表示，服务器重启都会加载该文件以加载数据。<strong>简称快照</strong></li>
<li>AOF（Append Only File）：AOF可以支持实时的数据持久化。AOF持久化功能通过保存redis服务器所执行的写命令来记录数据库状态，默认存储在appendonly.aof中，AOF文件中存储的都是redis相关命令。<strong>检查记录日志</strong></li>
</ul>
<p><strong>RDB持久化过程？</strong></p>
<ol>
<li>持久化部分：</li>
</ol>
<p>Redis有俩个命令进行RDB持久化：</p>
<p><strong>SAVE</strong>：将会阻塞redis进程，此时服务器不能处理任何命令请求，直到RDB文件创建完毕。<br><strong>BGSAVE</strong>：派生子进程（创建子进程执行fork函数时服务器也将会阻塞，不过用时会很短），由子进程创建RDB，服务器进程继续<br>bgsave命令持久化过程如下：</p>
<p>fork：创建子线程<br>rdbSave：子线程创建rdb文件（save命令相当于是父进程直接执行这个函数）<br>signal_parent：子线程创建完成后向父进程发送信号<br>RDB持久化可以手动执行，也可以根据服务器配置选项定期执行，在配置文件中设置save属性，会让服务器每隔一段时间自行执行一次bgsave命令。可以配置多个save选项，任一选项条件满足时都被会执行。</p>
<p><strong>AOF持久化过程？AOF持久化会出现阻塞吗？为什么？</strong></p>
<ol>
<li>持久化部分：<br>AOF持久化功能的实现可以分为命令追加、文件写入和同步。</li>
</ol>
<p>命令追加：当服务器完成一个写命令之后，并不会直接将这些命令写入AOF文件，而是以Redis协议格式将被执行的写命令追加到服务器缓冲区（aof_bug）的末尾。<br>文件写入与同步：根据设置的数据同步策略（always、everysec、no），当满足同步条件或缓冲区满时，redis会将AOF缓冲区中的数据一次性写入磁盘的AOF文件。</p>
<p><strong>AOF写日志的过程</strong></p>
<p><strong>always</strong>：每次执行写命令都将缓冲区的内容写入AOF文件。效率最慢，也最安全，故障停机只会丢失一个事件循环中的数据命令。<br>**everysec：**如果上次同步AOF文件时间距离现在已经超过了1秒，就进行文件同步。该同步由一个线程单独负责效率够快，且故障停机也只会丢失一秒钟的命令数据。<br>**no：**由操作系统决定何时进行AOF文件的同步。一般来说，os可能会等到缓冲区的空间被填满、或者超过了指定时限之后，才真正地将缓冲区的数据写入到磁盘里面。fsync和fdatasync两个同步函数，可以强制让os立即将缓冲区中的数据写入到磁盘里面。总体写入AOF文件的速度最快，但是单次同步时长是三种模式中最长的。</p>
<h3 id="6-3-一致性-延迟双删"><a href="#6-3-一致性-延迟双删" class="headerlink" title="6.3 一致性(延迟双删)"></a>6.3 一致性(延迟双删)</h3><h3 id="6-4-redis缓存穿透"><a href="#6-4-redis缓存穿透" class="headerlink" title="6.4 redis缓存穿透"></a>6.4 redis缓存穿透</h3><blockquote>
<p>缓存穿透：缓存中不存在，且数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
</blockquote>
<p>解决方案：</p>
<p>**缓存空值：**即使数据库查询结果为空，也将一个特殊标记（如“NULL”或“NOT_FOUND”）作为值缓存起来，并设置一个合理的过期时间，以便在短期内拦截相同的无效请求。<br>**布隆过滤器：**部署一个布隆过滤器，所有查询请求先经过过滤器验证，只有可能存在的数据才会进一步查询，这样可以过滤掉大部分肯定不存在的数据请求。</p>
<h3 id="6-5-雪崩问题"><a href="#6-5-雪崩问题" class="headerlink" title="6.5 雪崩问题"></a>6.5 雪崩问题</h3><blockquote>
<p>可能产生的场景：</p>
<ol>
<li>大量缓存同时过期：例如，若系统中的多个关键热数据的缓存设置了相同或相近的过期时间，一旦这些缓存同时过期，会导致大量请求直接打到数据库。</li>
<li>缓存实例故障：Redis服务器本身发生故障，如宕机或网络断开，导致整个缓存集群失去作用，所有请求无法命中缓存而转向数据库。</li>
<li>批量操作失误：由于运维或者其他原因，执行了错误的大规模删除缓存操作，使大量缓存数据瞬间失效。</li>
</ol>
</blockquote>
<ul>
<li><p>分散过期时间：对不同缓存数据设置随机的过期时间，避免同一时间点大量缓存同时失效。</p>
</li>
<li><p>二级缓存策略：采用主从、分层或多级缓存架构，即使一级缓存失效，还有其他层次的缓存可以抵挡一部分冲击。</p>
</li>
<li><p>熔断机制：引入类似Hystrix这样的熔断器组件，当请求量超过数据库能承受的阈值时，立即停止服务调用，避免压垮数据库。</p>
</li>
<li><p>限流&#x2F;降级：使用令牌桶或漏桶算法等实现流量控制，当请求过多时进行限流，优先确保核心服务的稳定。</p>
</li>
<li><p>后台更新缓存：在缓存失效时，不是立即从数据库加载数据并返回给客户端，而是异步地去更新缓存，减少数据库压力。</p>
</li>
<li><p>冗余设计：提升缓存集群的可用性和容错能力，即便部分节点失效，也能通过其他节点继续提供服务。</p>
</li>
</ul>
<h3 id="6-6-redis与db的一致性"><a href="#6-6-redis与db的一致性" class="headerlink" title="6.6 redis与db的一致性"></a>6.6 redis与db的一致性</h3><p><strong>1. Cache Aside Pattern（旁路缓存模式）</strong></p>
<ul>
<li><strong>读取操作</strong>：首先尝试从缓存中获取数据，如果缓存命中，则直接返回；否则，从数据库中读取数据并将其放入缓存，最后返回给客户端。</li>
<li><strong>更新操作</strong>：当需要更新数据时，首先更新数据库，然后再清除或使缓存中的对应数据失效。这样一来，后续的读请求将无法从缓存获取数据，从而迫使系统从数据库加载最新的数据并重新填充缓存。</li>
</ul>
<p><strong>2. 更新数据的时候加锁实现（强一致性）</strong></p>
<p>在更新请求的时候给这个数据加一个悲观锁，即读操作会被阻塞</p>
<p><strong>3. 在更新数据库的时候就将缓存一起更新</strong></p>
<pre><code>	1. 同步更新
	2. 异步更新，在更新完成数据库的时候，将要更新redis的消息丢给消息队列，让redis去监听这个消息队列去更新redis的数据
</code></pre>
<h2 id="七、多线程面试题"><a href="#七、多线程面试题" class="headerlink" title="七、多线程面试题"></a>七、多线程面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">熟悉多线程编程，掌握synchronized(锁升级)，线程池(参数，工作流程) ，ThreadLocal(内存泄露)。</span><br></pre></td></tr></table></figure>

<h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><h3 id="1-为什么使用并发编程"><a href="#1-为什么使用并发编程" class="headerlink" title="1. 为什么使用并发编程"></a>1. 为什么使用并发编程</h3><ul>
<li><strong>提升多核CPU的利用率：</strong> 在一个多核CPU的主机上，我们可以创建多个线程，将多个线程分配给不同的CPU去执行，每个CPU执行一个线程，这样就提高了CPU的使用效率。</li>
<li><strong>方便进行业务拆分：</strong> 面对复杂业务模型，可以对业务模块进行拆分，从而提升响应速度。而进行拆分时可以使用多线程技术来完成。</li>
</ul>
<p><strong>优点：提高了程序的执行效率，一定情况下可以提高程序运行速度。</strong><br><strong>缺点：可能出现内存泄漏、上下文切换、线程安全、死锁等问题。</strong></p>
<h3 id="2-并发编程三要素是什么？"><a href="#2-并发编程三要素是什么？" class="headerlink" title="2. 并发编程三要素是什么？"></a>2. 并发编程三要素是什么？</h3><ul>
<li><strong>可见性（Visibility）</strong><ul>
<li><strong>可见性指的是一个线程对共享变量的修改能够被其他线程立即看到的特性。</strong></li>
<li><strong>在多线程环境下，由于线程之间可能存在缓存不一致的问题，一个线程对共享变量的修改可能无法立即被其他线程感知。</strong></li>
<li><strong>为了保证可见性，可以使用<code>volatile</code>关键字或显式地使用锁（如<code>synchronized</code>或<code>Lock</code>）来实现。<code>volatile</code>关键字能够确保每次访问变量时，总是获取主内存的最新值，并且在修改后立即回写到主内存。</strong></li>
</ul>
</li>
<li><strong>原子性（Atomicity）</strong><ul>
<li><strong>原子性指的是一个操作是不可分割的、完整的，要么全部执行成功，要么全部不执行，不存在执行一半的情况。</strong></li>
<li><strong>在多线程环境下，非原子性操作可能会导致竞态条件（race condition）等问题，进而引发程序错误。</strong></li>
<li><strong>为了保证原子性，可以使用<code>synchronized</code>关键字或<code>Atomic</code>类中提供的原子操作。例如，<code>AtomicInteger</code>类中的<code>incrementAndGet()</code>方法就是原子操作。</strong></li>
</ul>
</li>
<li><strong>有序性（Ordering）</strong><ul>
<li><strong>有序性指的是程序执行的顺序必须符合预期，不能出现乱序的情况。</strong></li>
<li><strong>在多线程环境下，由于编译器优化、处理器指令重排等因素，程序执行的顺序可能会出现不一致的情况，从而导致程序错误。</strong></li>
<li><strong>为了保证有序性，可以使用<code>volatile</code>关键字或显式地使用锁。Java还提供了<code>happens-before</code>规则，该规则可以在特定情况下保证操作的顺序是按照预期的顺序执行的。</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>这三个要素是并发编程中确保线程安全、避免数据不一致和程序错误的关键。在设计和实现并发程序时，需要充分考虑这些因素，并采取相应的措施来保证程序的正确性和性能。</strong></p>
</blockquote>
<h3 id="3-并行、并发、串行的区别"><a href="#3-并行、并发、串行的区别" class="headerlink" title="3. 并行、并发、串行的区别"></a>3. 并行、并发、串行的区别</h3><ul>
<li><strong>串行：串行在时间上不可能发生重叠，前一个任务没有执行结束，下一个任务就不会开始</strong></li>
<li><strong>并行：并行在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行</strong></li>
<li><strong>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，同一时间点，只有一个任务执行，任务交替执行</strong></li>
</ul>
<h3 id="4-什么是线程和进程-两者的区别是什么？"><a href="#4-什么是线程和进程-两者的区别是什么？" class="headerlink" title="4. 什么是线程和进程?两者的区别是什么？"></a>4. 什么是线程和进程?两者的区别是什么？</h3><ul>
<li><strong>进程：程序的⼀次执⾏过程，是系统运⾏程序的基本单位。进程是动态的，系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。</strong></li>
<li><strong>线程：线程是进程划分成的更⼩的运⾏单位，进程中的一个执行任务，⼀个进程在其执⾏的过程中可以产⽣多个线程，在程序里独立执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享进程中的数据。</strong></li>
</ul>
<p><strong>进程与线程的区别：</strong></p>
<ul>
<li><strong>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</strong></li>
<li><strong>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，所以系统在产生⼀个线程，或是在各个线程之间作切换⼯作时，开销要⽐进程小得多，所以线程也被称为轻量级进程</strong></li>
<li><strong>内存分配：进程与进程之间的地址空间和资源是相互独立的，同一进程的线程共享本进程的地址空间和资源，线程之间可能会相互影响。</strong></li>
<li><strong>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。</strong></li>
<li><strong>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</strong></li>
</ul>
<h3 id="5-对线程安全的理解"><a href="#5-对线程安全的理解" class="headerlink" title="5. 对线程安全的理解"></a>5. 对线程安全的理解</h3><p><strong>当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的 。</strong></p>
<p>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆(内存)。进程内的所有线程都可以访问到该区域，这就是造成线程安全的潜在原因。</p>
<p>目前主流操作系统都是多任务的。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的</p>
<p><strong>如何保证线程安全？</strong></p>
<p><strong>方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger</strong><br><strong>方法二：使用JVM提供的自动锁 synchronized。</strong><br><strong>方法三：使用JDK提供的手动锁 Lock。</strong></p>
<h3 id="6-synchronized关键字的作用"><a href="#6-synchronized关键字的作用" class="headerlink" title="6. synchronized关键字的作用"></a>6. synchronized关键字的作用</h3><p><strong>synchronized 它可以把任意一个非 NULL 的对象当作锁。是非公平锁，他属于独占式的悲观锁，同时属于可重入锁。</strong></p>
<p><strong>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p><strong>三种使用方式：</strong></p>
<ul>
<li><strong>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li>
<li><strong>修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</strong></li>
<li><strong>修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</strong></li>
</ul>
<p><strong>总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能</strong></p>
<blockquote>
<p><strong>构造方法可以使用 synchronized 关键字修饰么？</strong><br>构造方法不能使用 synchronized 关键字修饰，构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
</blockquote>
<h3 id="7-volatile-关键字的作用"><a href="#7-volatile-关键字的作用" class="headerlink" title="7. volatile 关键字的作用"></a>7. volatile 关键字的作用</h3><p><strong>Java 提供了 volatile 关键字是线程同步的轻量级实现，用来保证可见性和有序性（禁止指令重排），volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</strong></p>
<ul>
<li><strong>对于加了 volatile关键字的成员变量，在对这个变量进行修改时，全直接将CPU高级缓存中的数据送回到主内存,对这个变量的读取也会直接从主内存中读取，从而保证了可见性</strong></li>
<li><strong>在对 volatile修饰的成员变量进行读写时，会插入内存屏障，而内存屏障可以达到禁止重排序的效果，从而可以保证有序性</strong></li>
</ul>
<p><strong>volatile可以和CAS 结合，来保证原子性。</strong></p>
<blockquote>
<p><strong>讲一下 JMM(Java 内存模型)</strong><br>在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，就需要把变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
</blockquote>
<blockquote>
<p><strong>volatile实现内存可见性原理：</strong><br><strong>一个问题：本地内存和主内存之间的值不一致，导致内存不可见。</strong><br>在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令。将当前处理器缓存行的数据写回系统内存，这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效，当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
</blockquote>
<blockquote>
<p><strong>volatile实现有序性原理：</strong><br>为了实现volatile的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。<br>内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p>
</blockquote>
<h3 id="8-什么是CAS"><a href="#8-什么是CAS" class="headerlink" title="8. 什么是CAS?"></a>8. 什么是CAS?</h3><p>CAS即Compare And Swap，比较并替换。是一条CPU并发原语，Java中可以通过CAS操作来保证原子性，它的功能是判断内存某个位置的值是否为预期值，如果是则更新为新的值，这个过程是原子的。</p>
<p>CAS并发原语提现在Java语言中就是<code>sun.misc.UnSafe</code>类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我实现CAS汇编指令。这是一种完全依赖于硬件功能，通过它实现了原子操作。原语的执行必须是连续的，在执行过程中不允许中断，也即是说CAS是一条原子指令，不会造成所谓的数据不一致的问题。</p>
<blockquote>
<p><strong>Unsafe：CAS的核心类，Java方法无法直接访问内存，需要通过本地方法native来访问，在Unsafe中所有方法都是native方法，用来直接操作内存，执行相应的任务。</strong></p>
</blockquote>
<blockquote>
<p><strong>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。类似于乐观锁。CAS自旋的概率会比较大，从而浪费更多的CPU资源。在这个过程中可能存在ABA问题：</strong><br><strong>当你获得对象当前数据后，在准备修改为新值前，对象的值被其他线程连续修改了两次（A-&gt;B-&gt;A），而经过两次修改后，对象的值又恢复为旧值，这样当前线程无法正确判断这个对象是否修改过。</strong></p>
</blockquote>
<p>ABA的问题的解决方式：</p>
<ul>
<li>ABA的解决方法也很简单，就是利用版本号。给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使E的值从A—&gt;B—&gt;A，版本号也发生了变化，这样就解决了CAS出现的ABA问题。基于CAS的乐观锁也是这个实现原理。</li>
<li>JDK1.5时可以利用AtomicStampedReference类来解决这个问题，AtomicStampedReference内部不仅维护了对象值，还维护了一个时间戳。当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳，对象值和时间戳都必须满足期望值，写入才会成功</li>
</ul>
<p>自旋：当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。</p>
<h3 id="9-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#9-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="9. 说说 synchronized 关键字和 volatile 关键字的区别"></a>9. 说说 synchronized 关键字和 volatile 关键字的区别</h3><p>synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong>volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比synchronized关键字要好 。</strong></li>
<li><strong>volatile 关键字只能用于变量，而synchronized 关键字可以修饰方法以及代码块 。</strong></li>
<li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong></li>
<li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h3 id="10-单例模式"><a href="#10-单例模式" class="headerlink" title="10. 单例模式"></a>10. 单例模式</h3><p><strong>双重校验锁实现对象单例（线程安全</strong>)</p>
<p>public class Singleton {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>uniqueInstance 采用 volatile 关键字修饰的原因： <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</strong></p>
<ul>
<li><strong>为 uniqueInstance 分配内存空间</strong></li>
<li><strong>初始化 uniqueInstance</strong></li>
<li><strong>将 uniqueInstance 指向分配的内存地址</strong></li>
</ul>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="11-谈谈-synchronized-和-ReentrantLock-的区别"><a href="#11-谈谈-synchronized-和-ReentrantLock-的区别" class="headerlink" title="11. 谈谈 synchronized 和 ReentrantLock 的区别"></a>11. 谈谈 synchronized 和 ReentrantLock 的区别</h3><ul>
<li><strong>synchronized是一个内置的Java关键字，ReentrantLock是一个类，实现了Lock接口</strong></li>
<li><strong>synchronized会自动加锁或释放锁，ReentrantLock需要手动加锁和释放锁</strong></li>
<li><strong>synchronized 无法判断获取锁的状态，ReentrantLock 可以判断是否获取到了锁</strong></li>
<li><strong>synchronized底层是JVM层面的锁，ReentrantLock是API层面的锁</strong></li>
<li><strong>synchronized是可重入锁，非公平锁，ReentrantLock是可重入锁，可以选择公平锁和非公平锁</strong></li>
<li><strong>synchronized锁的是对象，锁信息保存在对象头中，ReentrantLock锁的线程，通过代码中int类型的state标识来标识锁的状态</strong></li>
<li><strong>相比synchronized，ReentrantLock增加了一些高级功能。（等待可中断、可实现公平锁、可实现选择性通知）</strong></li>
</ul>
<blockquote>
<p><strong>Lock接口</strong><br><strong>在jdk1.5以后，增加了juc并发包且提供了Lock接口用来实现锁的功能，它除了提供了与synchroinzed关键字类似的同步功能，还提供了比synchronized更灵活api实现。可以把 Lock 看成是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁。</strong></p>
</blockquote>
<blockquote>
<p><strong>ReentrantLock</strong><br><strong>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</strong></p>
</blockquote>
<h3 id="12-什么是AQS？"><a href="#12-什么是AQS？" class="headerlink" title="12. 什么是AQS？"></a>12. 什么是AQS？</h3><p>AQS的全称是AbstractQueuedSynchronizer，是一个用来构建锁和同步器的框架，像ReentrantLock，Semaphore，FutureTask都是基于AQS实现的。</p>
<p>AQS的工作流程：AQS会维护一个共享资源，当被请求的共享资源空闲，则将请求资源的线程设为有效的工作线程，同时锁定共享资源。如果被请求的资源已经被占用了，AQS就用过队列实现了一套线程阻塞等待以及唤醒时锁分配的机制。</p>
<p>从图中可以看出AQS维护了一个共享资源和一个FIFO的线程等待队列。这个队列是通过CLH队列实现的，该队列是一个双向队列，有Node结点组成，每个Node结点维护一个prev引用和next引用，这两个引用分别指向自己结点的前驱结点和后继结点，同时AQS还维护两个指针Head和Tail，分别指向队列的头部和尾部。</p>
<h3 id="13-如何使用AQS自定义同步器？"><a href="#13-如何使用AQS自定义同步器？" class="headerlink" title="13. 如何使用AQS自定义同步器？"></a>13. 如何使用AQS自定义同步器？</h3><blockquote>
<p>AQS的资源共享方式：<br>Exclusive：独占，只有一个线程可以执行，例如ReentrantLock<br>Share：共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch</p>
</blockquote>
<p>AQS的底层使用了模板方法模式，自定义同步器只需要两步：<br>第一，继承AbstractQueuedSynchronizer，第二，重写以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式，尝试获取资源。</li>
<li>tryRelease(int)：独占方式，尝试释放资源。</li>
<li>tryAcquireShared(int)：共享方式，尝试获取资源。负数表示失败，0表示成功，但无剩余可用资源，正数表示成功并且有剩余资源</li>
<li>tryReleaseShared(int)：共享方式，尝试释放资源</li>
</ul>
<blockquote>
<p>独占式的ReentrantLock实现方式：，state初始状态为0，表示未锁定状态。A线程进行lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再调用tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
</blockquote>
<blockquote>
<p>共享式的CountDownLatch实现方式：任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
</blockquote>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<h3 id="14-CopyOnWriteArrayList"><a href="#14-CopyOnWriteArrayList" class="headerlink" title="14. CopyOnWriteArrayList"></a>14. CopyOnWriteArrayList</h3><p>我们都知道将ArrayList作为共享变量，在多线程的情况下是不安全的，解决方法是使用Collections中的SynchronizedList方法，或者我们代码中进行加锁，其实还有另一种线程安全的List，就是CopyOnWriteArrayList。</p>
<p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对CopyOnWrite容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。</p>
<p>先对CopyOnWriteArrayList进行一个总体概览，它具有三个特点：</p>
<ul>
<li>线程安全的，多线程环境下可以直接使用，无需加锁；</li>
<li>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</li>
<li>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</li>
</ul>
<h3 id="15-CountDownLatch、CyclicBarrier、Semaphore的区别"><a href="#15-CountDownLatch、CyclicBarrier、Semaphore的区别" class="headerlink" title="15. CountDownLatch、CyclicBarrier、Semaphore的区别"></a>15. CountDownLatch、CyclicBarrier、Semaphore的区别</h3><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同；</p>
<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</li>
<li>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li>
<li>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</li>
</ul>
<p>Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
<blockquote>
<p>CountDownLatch：计数器，允许一个或多个线程等待直到其他线程中执行的一组操作完成同步辅助。可以用于高并发测试，即计数积累了一定数量的线程后再一起执行。<br>原理：<br>countDownLatch.countDown(); &#x2F;&#x2F; 计数器数量-1<br>countDownLatch.await(); &#x2F;&#x2F; 线程会被挂起，等待计数器归零，然后再向下执行，可以设置等待时间</p>
</blockquote>
<p>import java.util.concurrent.CountDownLatch; &#x2F;&#x2F; 计数器<br>public class CountDownLatchDemo {<br>	public static void main(String[] args) throws InterruptedException { 
	    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch; <span class="comment">// 计数器 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">// 总数是6，必须要执行任务的时候，再使用！ </span></span><br><span class="line">		<span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>); </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line"> 			<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line"> 				System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Go out&quot;</span>); </span><br><span class="line"> 				countDownLatch.countDown(); <span class="comment">// 数量-1 </span></span><br><span class="line"> 			&#125;,String.valueOf(i)).start(); </span><br><span class="line"> 		&#125;</span><br><span class="line">		countDownLatch.await(); <span class="comment">// 等待计数器归零，然后再向下执行 </span></span><br><span class="line">		System.out.println(<span class="string">&quot;Close Door&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-锁分类"><a href="#16-锁分类" class="headerlink" title="16. 锁分类"></a>16. 锁分类</h3><h4 id="是否锁同步资源：乐观锁、悲观锁"><a href="#是否锁同步资源：乐观锁、悲观锁" class="headerlink" title="是否锁同步资源：乐观锁、悲观锁"></a>是否锁同步资源：乐观锁、悲观锁</h4><p><strong>乐观锁：一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</strong></p>
<blockquote>
<p><strong>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</strong></p>
</blockquote>
<p><strong>悲观锁：一种悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是synchronized；</strong></p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul>
<li><strong>是否锁同步资源</strong>：<strong>不锁住同步资源</strong>。乐观锁总是假设最好的情况，即每次去拿数据的时候都认为别人不会修改，所以在拿数据的时候不会上锁。</li>
<li><strong>实现方式</strong>：乐观锁在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS（Compare-And-Swap，比较并交换）算法实现。CAS操作通常涉及三个参数：内存位置（V）、预期原值（A）和新值（B）。如果内存位置的当前值与预期原值相等，那么CAS操作将该内存位置的值更新为新值；如果当前值与预期原值不同，则CAS操作不执行任何操作。</li>
<li><strong>适用场景</strong>：乐观锁适合读操作多的场景，因为不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul>
<li><strong>是否锁同步资源</strong>：<strong>锁住同步资源</strong>。悲观锁总是假设最坏的情况，即每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</li>
<li><strong>实现方式</strong>：在Java中，synchronized关键字和Lock的实现类（如ReentrantLock）都是悲观锁的实现方式。它们通过锁定资源来确保在并发环境下数据的一致性和安全性。</li>
<li><strong>适用场景</strong>：悲观锁适合写操作多的场景，因为先加锁可以保证写操作时数据的正确性。同时，悲观锁也适用于临界区持锁时间比较长、临界区有IO操作、临界区代码复杂或者循环量大、临界区竞争非常激烈等场景。</li>
</ul>
<h4 id="线程是否阻塞：自旋锁"><a href="#线程是否阻塞：自旋锁" class="headerlink" title="线程是否阻塞：自旋锁"></a>线程是否阻塞：自旋锁</h4><p><strong>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</strong></p>
<p>线程自旋是需要消耗 CPU 的，说白了就是让 CPU在做无用功，如果一直获取不到锁，那线程也不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p><strong>自旋锁的优点：</strong><br><strong>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</strong></p>
<h4 id="线程竞争时是否排队：公平锁、非公平锁"><a href="#线程竞争时是否排队：公平锁、非公平锁" class="headerlink" title="线程竞争时是否排队：公平锁、非公平锁"></a>线程竞争时是否排队：公平锁、非公平锁</h4><ul>
<li><strong>公平锁：锁的分配机制是公平的，加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</strong></li>
<li><strong>非公平锁：加锁时不考虑排队等待问题，JVM 按随机、就近原则分配锁的机制则称为不公平锁，非公平锁实际执行的效率要远远超出公平锁（5-10倍），除非程序有特殊需要，否则最常用非公平锁的分配机制。特点 ：synchronized</strong></li>
</ul>
<h4 id="线程中的多个流程是否可以获取同一把锁：可重入锁（递归锁）"><a href="#线程中的多个流程是否可以获取同一把锁：可重入锁（递归锁）" class="headerlink" title="线程中的多个流程是否可以获取同一把锁：可重入锁（递归锁）"></a>线程中的多个流程是否可以获取同一把锁：可重入锁（递归锁）</h4><p><strong>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是可重入锁。</strong></p>
<h4 id="多线程之间能不能共享同一把锁：共享锁和排他锁"><a href="#多线程之间能不能共享同一把锁：共享锁和排他锁" class="headerlink" title="多线程之间能不能共享同一把锁：共享锁和排他锁"></a>多线程之间能不能共享同一把锁：共享锁和排他锁</h4><ul>
<li><strong>共享锁：共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</strong></li>
<li><strong>排他锁：每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读&#x2F;读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</strong></li>
</ul>
<h4 id="锁状态：无锁、偏向锁、轻量级锁、重量级锁"><a href="#锁状态：无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="锁状态：无锁、偏向锁、轻量级锁、重量级锁"></a>锁状态：无锁、偏向锁、轻量级锁、重量级锁</h4><p><strong>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。</strong></p>
<p><strong>锁升级：随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，<br>也就是说只能从低到高升级，不会出现锁的降级）。</strong></p>
<ul>
<li><strong>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</strong></li>
<li><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能</strong></li>
<li><strong>轻量级锁：当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</strong></li>
<li><strong>重量级锁：升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</strong></li>
</ul>
<h3 id="17-死锁"><a href="#17-死锁" class="headerlink" title="17. 死锁"></a>17. 死锁</h3><p><strong>两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法让程序进行下去！</strong></p>
<p><strong>如何查看线程死锁：通过<code>jstack命令</code>进行查看，jstack中会显示发生死锁的线程</strong></p>
<blockquote>
<p>数据库中查看死锁：<br>查看是否有表锁：<code>show OPEN TABLES where In_use &gt; 0；</code><br>查询进程：<code>show processlist;</code><br>查看正在锁的事务：<code>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</code><br>查看等待锁的事务：<code>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS_WAITS;</code></p>
</blockquote>
<h4 id="1-互斥条件（Mutual-Exclusion）"><a href="#1-互斥条件（Mutual-Exclusion）" class="headerlink" title="1. 互斥条件（Mutual Exclusion）"></a>1. 互斥条件（Mutual Exclusion）</h4><p><strong>资源不能共享，只能被同一个进程使用</strong></p>
<p>​     	互斥条件指的是至少有一个资源必须处于非共享模式，即一次只能被一个线程（或进程）使用。如果某个线程已经获取了某个资源，其他线程就必须等待该线程释放资源后才能使用。这是死锁发生的基础条件，因为资源的独占性导致了线程间的竞争。</p>
<h4 id="2-请求与保持条件（Hold-and-Wait）"><a href="#2-请求与保持条件（Hold-and-Wait）" class="headerlink" title="2. 请求与保持条件（Hold and Wait）"></a>2. 请求与保持条件（Hold and Wait）</h4><p><strong>以及得到的资源可以申请新的资源</strong></p>
<p>​		一个线程已经持有了至少一个资源，并且正在等待获取其他线程持有的资源。这种情况下，线程不会释放自己已经持有的资源，而是继续等待其他资源变得可用。这种占有且等待的行为可能导致死锁，因为线程可能无限期地等待其他线程释放资源。</p>
<h4 id="3-不可剥夺条件（No-Preemption）"><a href="#3-不可剥夺条件（No-Preemption）" class="headerlink" title="3. 不可剥夺条件（No Preemption）"></a>3. 不可剥夺条件（No Preemption）</h4><p><strong>已经分配的资源不能从相应的进程中强制剥夺</strong></p>
<p>​		已经分配给一个线程的资源不能被其他线程强制剥夺，只有该线程自己使用完毕后才能释放资源。这意味着即使线程不再需要某个资源，或者因为某些原因被阻塞而无法继续执行，其他线程也不能直接夺取该资源。这种不可剥夺性增加了死锁的风险，因为线程可能无法及时释放资源以满足其他线程的需求。</p>
<h4 id="4-循环等待条件（Circular-Wait）"><a href="#4-循环等待条件（Circular-Wait）" class="headerlink" title="4. 循环等待条件（Circular Wait）"></a>4. 循环等待条件（Circular Wait）</h4><p><strong>系统中若干进程形成环路，该环路中每个进程都在等待相邻进程占用的资源</strong></p>
<p>​		多个线程之间形成了一个环形的等待链，每个线程都在等待下一个线程释放资源。具体来说，存在一个线程序列P1, P2, …, Pn，其中P1等待P2持有的资源，P2等待P3持有的资源，依此类推，直到Pn等待P1持有的资源。这种循环等待的关系导致了死锁的发生，因为每个线程都在等待其他线程释放资源，而这些资源又被其他线程所持有。</p>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>**破环产生死锁的必要条件 **</p>
<p><strong>破环互斥条件：这个无法进行破环。锁的作用就是让他们互斥。</strong></p>
<p><strong>破环请求与保持条件：一次性申请所有资源</strong> </p>
<p><strong>破环不可剥夺条件：线程在申请不到所需资源时，主动放弃所持有的资源。</strong></p>
<p><strong>破环循环等待条件：按照顺序来申请资源</strong></p>
<h3 id="18-线程的三大特性"><a href="#18-线程的三大特性" class="headerlink" title="18. 线程的三大特性"></a>18. 线程的三大特性</h3><ol>
<li><strong>原子性（Atomicity）</strong><ul>
<li><strong>原子性指的是一个或多个操作要么全部执行，并且执行过程中不会被任何因素打断，要么就都不执行。这保证了数据的一致性和线程的安全性。</strong></li>
<li><strong>在Java中，可以通过<code>synchronized</code>关键字或<code>java.util.concurrent.atomic</code>包下的原子类（如<code>AtomicInteger</code>、<code>AtomicLong</code>等）来实现操作的原子性。</strong></li>
</ul>
</li>
<li><strong>可见性（Visibility）</strong><ul>
<li><strong>可见性是指当多个线程同时访问一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到这个修改后的值。</strong></li>
<li><strong>由于CPU缓存的存在，一个线程对共享变量的修改可能不会立即对其他线程可见。在Java中，可以通过<code>volatile</code>关键字来确保变量的修改对所有线程可见。此外，<code>synchronized</code>关键字也能保证可见性，因为它在释放锁时会将共享变量的最新值刷新到主存中。</strong></li>
</ul>
</li>
<li><strong>有序性（Ordering）</strong><ul>
<li><strong>有序性是指程序执行的顺序按照代码的先后顺序执行。然而，在并发编程中，为了提高性能，编译器和处理器可能会对指令进行重排序。这种重排序在单线程环境下通常不会影响程序的执行结果，但在多线程环境下却可能导致问题。</strong></li>
<li><strong>Java语言规范通过<code>happens-before</code>规则来定义哪些操作是有序的。此外，<code>volatile</code>关键字和<code>synchronized</code>关键字也能在一定程度上保证有序性。例如，<code>volatile</code>变量的写操作会先于读操作发生，而<code>synchronized</code>块内的操作则是有序的。</strong></li>
</ul>
</li>
</ol>
<h3 id="19-创建线程有哪几种方式？"><a href="#19-创建线程有哪几种方式？" class="headerlink" title="19. 创建线程有哪几种方式？"></a>19. 创建线程有哪几种方式？</h3><p><strong>继承 Thread 类，重写run方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123; </span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法正在执行...&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现 Runnable 接口，实现run方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现 Callable 接口，实现call方法。通过FutureTask创建一个线程，获取到线程执行的返回值：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123; </span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123; </span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; call()方法执行 中...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 Executors 工具类创建线程池，并开启线程。</strong></p>
<h3 id="20-Thread、Runable和Callable-三者区别？"><a href="#20-Thread、Runable和Callable-三者区别？" class="headerlink" title="20. Thread、Runable和Callable 三者区别？"></a>20. Thread、Runable和Callable 三者区别？</h3><ul>
<li>Thread 是一个抽象类，只能被继承，而 Runable、Callable 是接口，需要实现接口中的方法。继承 Thread 重写run()方法，实现Runable接口需要实现run()方法，而Callable是需要实现call()方法。</li>
<li>Thread 和 Runable 没有返回值，Callable 有返回值，返回值可以被 Future 拿到。</li>
<li>实现 Runable 接口的类不能直接调用start()方法，需要 new 一个 Thread 并发该实现类放入 Thread，再通过新建的 Thread 实例来调用start()方法。实现 Callable 接口的类需要借助 FutureTask (将该实现类放入其中)，再将 FutureTask 实例放入 Thread，再通过新建的 Thread 实例来调用start()方法。获取返回值只需要借助 FutureTask 实例调用get()方法即可！</li>
</ul>
<blockquote>
<p><strong>什么是 FutureTask?</strong><br>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>
</blockquote>
<h3 id="21-线程的-run-和-start-有什么区别？"><a href="#21-线程的-run-和-start-有什么区别？" class="headerlink" title="21. 线程的 run()和 start()有什么区别？"></a>21. 线程的 run()和 start()有什么区别？</h3><p><strong>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</strong></p>
<p><strong>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</strong></p>
<p>run() 可以重复调用，而 start()只能调用一次。</p>
<p><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？</strong></p>
<p><strong>如果直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
<h3 id="22-线程的状态"><a href="#22-线程的状态" class="headerlink" title="22. 线程的状态"></a>22. 线程的状态</h3><p><strong>线程通常有5种状态：新建、就绪、运行、阻塞和死亡状态</strong></p>
<ul>
<li><strong>新建(new)：新创建了一个线程对象。</strong></li>
<li><strong>就绪(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</strong></li>
<li><strong>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</strong></li>
<li><strong>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</strong><br><strong>阻塞的情况分三种：</strong><br>① 等待阻塞(wait-&gt;等待对列)：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waittingqueue)中，使本线程进入到等待阻塞状态；<br>② 同步阻塞(lock-&gt;锁池)：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；<br>③ 其他阻塞(sleep&#x2F;join)： 通过调用线程的 sleep()或 join()或发出了 I&#x2F;O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</li>
<li><strong>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</strong></li>
</ul>
<h3 id="23-线程基本方法"><a href="#23-线程基本方法" class="headerlink" title="23. 线程基本方法"></a>23. 线程基本方法</h3><ul>
<li><strong>线程等待wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；只有等待另外线程的通知或被中断才会返回，wait 方法一般用在同步方法或同步代码块中</strong></li>
<li><strong>线程睡眠sleep()：使一个正在运行的线程处于睡眠状态，但不会释放当前占有的锁。是一个静态方法，调用此方法要处理InterruptedException 异常；</strong></li>
<li><strong>等待其他线程终止 join()：线程进入阻塞状态，马上释放cpu的执行权，但依然会保留cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行</strong></li>
<li><strong>线程让步yield()：使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片，执行后线程进入阻塞状态，例如在线程B种调用线程A的join()，那线程B会进入到阻塞队列，直到线程A结束或中断线程。</strong></li>
<li><strong>线程唤醒notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</strong></li>
<li><strong>线程全部唤醒notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</strong></li>
</ul>
<h3 id="24-sleep-和-wait-有什么区别？"><a href="#24-sleep-和-wait-有什么区别？" class="headerlink" title="24. sleep() 和 wait() 有什么区别？"></a>24. sleep() 和 wait() 有什么区别？</h3><p><strong>两者都可以暂停线程的执行</strong></p>
<ul>
<li><p><strong>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</strong></p>
</li>
<li><p><strong>是否释放锁：sleep() 不释放锁；wait() 释放锁，并且会加入到等待队列中。</strong></p>
</li>
<li><p><strong>是否依赖synchronized关键字：sl·eep不依赖synchronized关键字，wait需要依赖synchronized关键字</strong></p>
</li>
<li><p><strong>用途不同：sleep 通常被用于休眠线程；wait 通常被用于线程间交互&#x2F;通信，</strong></p>
</li>
<li><p><strong>用法不同：sleep() 方法执行完成后，不需要被唤醒，线程会自动苏醒，或者可以使用wait(longtimeout)超时后线程会自动苏醒。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。</strong></p>
</li>
</ul>
<h3 id="25-什么是上下文切换"><a href="#25-什么是上下文切换" class="headerlink" title="25.什么是上下文切换?"></a>25.什么是上下文切换?</h3><p><strong>巧妙地利用了时间片轮转的方式， CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。</strong></p>
<p><strong>上下文：指某一时间点 CPU 寄存器和程序计数器的内容</strong></p>
<p><strong>几种发生上下文切换的情况：</strong></p>
<ul>
<li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞，被终止或结束运行</li>
</ul>
<h3 id="26-线程之间如何进行通信"><a href="#26-线程之间如何进行通信" class="headerlink" title="26. 线程之间如何进行通信"></a>26. 线程之间如何进行通信</h3><ul>
<li>通过共享内存或基于网络通信</li>
<li>如果是基于共享内存进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒</li>
<li>想Java中的wait()、notify()就是阻塞唤醒</li>
<li>通过网络就比较简单，通过网络连接将数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式。</li>
</ul>
<h3 id="27-说一下ThreadLocal"><a href="#27-说一下ThreadLocal" class="headerlink" title="27. 说一下ThreadLocal"></a>27. 说一下ThreadLocal</h3><p><strong>ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据。</strong></p>
<p><strong>ThreadLocal底层是通过 TreadLocalMap来实现的，每个Thread对象中都存在一个 ThreadLocalMap，Map的key为 ThreadLocal对象，Map的 value为需要缓存的值 。</strong></p>
<ul>
<li><strong>ThreadLocalMap由一个个 Entry对象构成 Entry继承自 WeakReference&lt; Threadlocal&lt;?&gt;&gt;，一个 Entry由 Threadlocal对象和 object构成，由此可见，Entry的key是 Threadlocal对象，并且是一个弱引用。当没指向key的强引用后，该key就会被垃圾收集器回收</strong></li>
<li><strong>当执行set方法时， Threadlocal首先会获取当前线程对象，然后获取当前线程的 ThreadLocalMap对象。再以当前 Threadlocal对象为key，将值存储进 Threadlocalmap对象中</strong></li>
<li><strong>get方法执行过程类似，Threadloca首先会获取当前线程对象，然后获取当前线程的 ThreadLocalMap对象。再以当前 ThreadLocal对象为key，获取对应的value</strong></li>
</ul>
<p><strong>由于每条线程均含有各自私有的 ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。</strong></p>
<p><strong>使用场景：</strong></p>
<ul>
<li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束</li>
<li>线程间数据隔离</li>
<li>进行事务操作，用于存储线程事务信息</li>
<li>数据库连接，Session会话管理</li>
</ul>
<blockquote>
<p>Spring框架在事务开始时会给当前线程绑定一个 Jdbc Connection，在整个事务过程都是使用该线程定的connection来执行数据库操作，实现了事务的隔离性， spring框架里面就是用的 Threadlocal来实现这种隔离。</p>
</blockquote>
<h3 id="28-ThreadLocal内存泄漏原因，如何避免？"><a href="#28-ThreadLocal内存泄漏原因，如何避免？" class="headerlink" title="28. ThreadLocal内存泄漏原因，如何避免？"></a>28. ThreadLocal内存泄漏原因，如何避免？</h3><p>如果在线程池中使用 ThreadLocal会造成内存泄漏，因为当 ThreadLocal对象使用完之后，<strong>应该要把设置的key，value也就是Entry对象进行回收</strong>，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap， ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，<strong>Entry对象也就不会被回收，从而出现内存泄漏。</strong></p>
<p><strong>解决办法：</strong></p>
<ul>
<li><p><strong>在使用了 ThreadLocal对象之后，手动调用ThreadLocal的 remove方法，手动清除Entry对象</strong></p>
</li>
<li><p><strong>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能将通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</strong></p>
</li>
</ul>
<h3 id="29-线程池的原理？"><a href="#29-线程池的原理？" class="headerlink" title="29. 线程池的原理？"></a>29. 线程池的原理？</h3><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用；控制最大并发数；管理线程。</strong></p>
<p>重用存在的线程，减少对象创建销毁的开销，且提高了响应速度；有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，且可以定时定期执行、单线程、并发数控制，配置任务过多任务后的拒绝策略等功能。</p>
<p><strong>线程池类别：</strong></p>
<ul>
<li><strong>newFixedThreadPool ：一个定长线程池，可控制线程最大并发数。</strong></li>
<li><strong>newCachedThreadPool：一个可缓存线程池。</strong></li>
<li><strong>newSingleThreadExecutor：一个单线程化的线程池，用唯一的工作线程来执行任务。</strong></li>
<li><strong>newScheduledThreadPool：一个定长线程池，支持定时&#x2F;周期性任务执行。</strong></li>
</ul>
<blockquote>
<p><strong>线程池尽量不要使用 Executors 去创建，而是通过 ThreadPoolExecutor的方式去创建，因为Executors创建的线程池底层也是调用 ThreadPoolExecutor，只不过使用不同的参数、队列、拒绝策略等如果使用不当，会造成资源耗尽问题。直接使用ThreadPoolExecutor让使用者更加清楚线程池允许规则，常见参数的使用，避免风险。</strong></p>
</blockquote>
<p><strong>主要参数：</strong></p>
<ul>
<li><strong>corePoolSize：核心线程数，默认情况下创建的线程数，默认情况下核心线程会一直存活，是一个常驻线程。一般公式： 核心线程数 &#x3D; cpu的核心数 * （1 + 线程的等待时间&#x2F;线程的总时间）</strong></li>
<li><strong>maximumPoolSize：线程池维护线程的最大数量，超过将被阻塞！（当核心线程满，且阻塞队列也满时，才会判断当前线程数是否小于最大线程数，才决定是否创建新线程）</strong></li>
<li><strong>keepAliveTime：非核心线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于 corePoolSize。</strong></li>
<li><strong>unit：指定 keepAliveTime 的单位，如 TimeUnit.SECONDS、TimeUnit.MILLISECONDS</strong></li>
<li><strong>workQueue：线程池中的任务队列，常用的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue。</strong></li>
<li><strong>threadFactory：创建新线程时使用的工厂</strong></li>
<li><strong>handler：RejectedExecutionHandler 是一个接口且只有一个方法，线程池中的数量大于 maximumPoolSize，对拒绝任务的处理策略，默认有 4 种策略：AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</strong></li>
</ul>
<h3 id="29-线程池的四种拒绝策略"><a href="#29-线程池的四种拒绝策略" class="headerlink" title="29. 线程池的四种拒绝策略"></a>29. 线程池的四种拒绝策略</h3><p><strong>AbortPolicy：中止策略。默认的拒绝策略，直接抛出 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</strong></p>
<p><strong>DiscardPolicy：抛弃策略。什么都不做，直接抛弃被拒绝的任务。</strong></p>
<p><strong>DiscardOldestPolicy：抛弃最老策略。抛弃阻塞队列中最老的任务，相当于就是队列中下一个将要被执行的任务，然后重新提交被拒绝的任务。如果阻塞队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将该策略和优先级队列放在一起使用。</strong></p>
<p><strong>CallerRunsPolicy：调用者运行策略。在调用者线程中执行该任务。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者（调用线程池执行任务的主线程），由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得线程池有时间来处理完正在执行的任务。</strong></p>
<h3 id="30-线程池中线程复用的原理"><a href="#30-线程池中线程复用的原理" class="headerlink" title="30. 线程池中线程复用的原理"></a>30. 线程池中线程复用的原理</h3><ul>
<li>线程池将线程和任务讲行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread创建线程时的个线程必须对应一个任务的限制。</li>
<li>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread进行了封装，并不是每次执行任务都会调用 Thread. start()来创建新线程，而是让<code>每个线程去执行一个循环任务</code>，在这个循环任务中<code>不停检查是否有任务需要被执行</code>，如果有则直接执行，也就是调用任务中的run方法，将run方法当成一个普通的方法执行，通过这种方式只使用固定的线程就将所有任务的run方法串联起来。</li>
</ul>
<h3 id="31-如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#31-如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="31. 如果你提交任务时，线程池队列已满，这时会发生什么"></a>31. 如果你提交任务时，线程池队列已满，这时会发生什么</h3><ul>
<li><strong>如果使用的是无界队列，没关系，继续添加任务到阻塞队列中等待执行</strong></li>
<li><strong>如果使用的是有界队列，任务首先会被添加到队列中，如果队列满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，队列依然是满的，那么则会使用拒绝策略处理满了的任务，默认是 AbortPolicy。</strong></li>
</ul>
<h3 id="32-阻塞队列的作用"><a href="#32-阻塞队列的作用" class="headerlink" title="32. 阻塞队列的作用"></a>32. 阻塞队列的作用</h3><p><strong>—般的 队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务了，阻塞队列 通过阻塞可以保留住当前要继续入队的任务。</strong></p>
<p><strong>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放CPU资源。<br>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活、不至于一直占用cpu资源。</strong></p>
<blockquote>
<p><strong>为什么先添加队列而不是先创建最大线程？</strong><br>在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影晌了整体效率。 就好比一个企业甲面有10个(core)正式工的名额，最多招10个正式工，要是任务超过正式工人数(task&gt;core)的情况下，工厂领导(线程池)不是首先扩招工人，还是这10人，但是任务可以稍微积压一下，即先放到队列去(代价低)。10个正式工慢慢干，迟早会干完的，要是任务还在继续增加，超过正式工的加班忍耐极限了(队列满了)，就的招外包帮忙了(注意是临时工)要是正式工加上外包还是不能完成任务，那新来的任务就会被领导拒绝了(线程池的拒绝策略)</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/01/31/%E7%AE%80%E5%8E%86%E4%B8%8A%E7%9A%84%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94/" data-id="cm6kt9gyf0000q8v3fu7n5wwi" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/01/31/%E7%AE%80%E5%8E%86%E4%B8%8A%E7%9A%84%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>